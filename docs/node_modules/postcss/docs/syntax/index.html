<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>node_modules/postcss/docs/syntax · Underbase</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="&lt;h1&gt;&lt;a class=&quot;anchor&quot; aria-hidden=&quot;true&quot; id=&quot;how-to-write-custom-syntax&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#how-to-write-custom-syntax&quot; aria-hidden=&quot;true&quot; class=&quot;hash-link&quot;&gt;&lt;svg class=&quot;hash-link-icon&quot; aria-hidden=&quot;true&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;How to Write Custom Syntax&lt;/h1&gt;
"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="node_modules/postcss/docs/syntax · Underbase"/><meta property="og:type" content="website"/><meta property="og:url" content="https://sundowndev.github.io/underbase/"/><meta property="og:description" content="&lt;h1&gt;&lt;a class=&quot;anchor&quot; aria-hidden=&quot;true&quot; id=&quot;how-to-write-custom-syntax&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#how-to-write-custom-syntax&quot; aria-hidden=&quot;true&quot; class=&quot;hash-link&quot;&gt;&lt;svg class=&quot;hash-link-icon&quot; aria-hidden=&quot;true&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;How to Write Custom Syntax&lt;/h1&gt;
"/><meta property="og:image" content="https://sundowndev.github.io/underbase/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://sundowndev.github.io/underbase/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/underbase/img/logo.svg"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="alternate" type="application/atom+xml" href="https://sundowndev.github.io/underbase/blog/atom.xml" title="Underbase Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://sundowndev.github.io/underbase/blog/feed.xml" title="Underbase Blog RSS Feed"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="/underbase/js/scrollSpy.js"></script><link rel="stylesheet" href="/underbase/css/main.css"/><script src="/underbase/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/underbase/"><img class="logo" src="/underbase/img/logo.svg" alt="Underbase"/><h2 class="headerTitleWithLogo">Underbase</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/underbase/docs/installation" target="_self">Guides</a></li><li class=""><a href="/underbase/docs/api" target="_self">API</a></li><li class=""><a href="/underbase/blog/" target="_self">Release notes</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle">node_modules/postcss/docs/syntax</h1></header><article><div><span><h1><a class="anchor" aria-hidden="true" id="how-to-write-custom-syntax"></a><a href="#how-to-write-custom-syntax" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>How to Write Custom Syntax</h1>
<p>PostCSS can transform styles in any syntax, and is not limited to just CSS.
By writing a custom syntax, you can transform styles in any desired format.</p>
<p>Writing a custom syntax is much harder than writing a PostCSS plugin, but
it is an awesome adventure.</p>
<p>There are 3 types of PostCSS syntax packages:</p>
<ul>
<li><strong>Parser</strong> to parse input string to node’s tree.</li>
<li><strong>Stringifier</strong> to generate output string by node’s tree.</li>
<li><strong>Syntax</strong> contains both parser and stringifier.</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="syntax"></a><a href="#syntax" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Syntax</h2>
<p>A good example of a custom syntax is <a href="https://github.com/postcss/postcss-scss">SCSS</a>. Some users may want to transform
SCSS sources with PostCSS plugins, for example if they need to add vendor
prefixes or change the property order. So this syntax should output SCSS from
an SCSS input.</p>
<p>The syntax API is a very simple plain object, with <code>parse</code> &amp; <code>stringify</code>
functions:</p>
<pre><code class="hljs css language-js"><span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">parse</span>:     <span class="hljs-built_in">require</span>(<span class="hljs-string">'./parse'</span>),
  <span class="hljs-attr">stringify</span>: <span class="hljs-built_in">require</span>(<span class="hljs-string">'./stringify'</span>)
}
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="parser"></a><a href="#parser" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Parser</h2>
<p>A good example of a parser is <a href="https://github.com/postcss/postcss-safe-parser">Safe Parser</a>, which parses malformed/broken CSS.
Because there is no point to generate broken output, this package only provides
a parser.</p>
<p>The parser API is a function which receives a string &amp; returns a <a href="http://api.postcss.org/Root.html"><code>Root</code></a> node.
The second argument is a function which receives an object with PostCSS options.</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">const</span> postcss = <span class="hljs-built_in">require</span>(<span class="hljs-string">'postcss'</span>)

<span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parse</span> (<span class="hljs-params">css, opts</span>) </span>{
  <span class="hljs-keyword">const</span> root = postcss.root()
  <span class="hljs-comment">// Add other nodes to root</span>
  <span class="hljs-keyword">return</span> root
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="main-theory"></a><a href="#main-theory" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Main Theory</h3>
<p>There are many books about parsers; but do not worry because CSS syntax is
very easy, and so the parser will be much simpler than a programming language
parser.</p>
<p>The default PostCSS parser contains two steps:</p>
<ol>
<li><a href="https://github.com/postcss/postcss/blob/master/lib/tokenize.es6">Tokenizer</a> which reads input string character by character and builds a
tokens array. For example, it joins space symbols to a <code>['space', '\n ']</code>
token, and detects strings to a <code>['string', '&quot;\&quot;{&quot;']</code> token.</li>
<li><a href="https://github.com/postcss/postcss/blob/master/lib/parser.es6">Parser</a> which reads the tokens array, creates node instances and
builds a tree.</li>
</ol>
<h3><a class="anchor" aria-hidden="true" id="performance"></a><a href="#performance" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Performance</h3>
<p>Parsing input is often the most time consuming task in CSS processors. So it
is very important to have a fast parser.</p>
<p>The main rule of optimization is that there is no performance without a
benchmark. You can look at <a href="https://github.com/postcss/benchmark">PostCSS benchmarks</a> to build your own.</p>
<p>Of parsing tasks, the tokenize step will often take the most time, so its
performance should be prioritized. Unfortunately, classes, functions and
high level structures can slow down your tokenizer. Be ready to write dirty
code with repeated statements. This is why it is difficult to extend the
default <a href="https://github.com/postcss/postcss/blob/master/lib/tokenize.es6">PostCSS tokenizer</a>; copy &amp; paste will be a necessary evil.</p>
<p>Second optimization is using character codes instead of strings.</p>
<pre><code class="hljs css language-js"><span class="hljs-comment">// Slow</span>
string[i] === <span class="hljs-string">'{'</span>

<span class="hljs-comment">// Fast</span>
<span class="hljs-keyword">const</span> OPEN_CURLY = <span class="hljs-number">123</span> <span class="hljs-comment">// `{'</span>
string.charCodeAt(i) === OPEN_CURLY
</code></pre>
<p>Third optimization is “fast jumps”. If you find open quotes, you can find
next closing quote much faster by <code>indexOf</code>:</p>
<pre><code class="hljs css language-js"><span class="hljs-comment">// Simple jump</span>
next = string.indexOf(<span class="hljs-string">'"'</span>, currentPosition + <span class="hljs-number">1</span>)

<span class="hljs-comment">// Jump by RegExp</span>
regexp.lastIndex = currentPosion + <span class="hljs-number">1</span>
regexp.test(string)
next = regexp.lastIndex
</code></pre>
<p>The parser can be a well written class. There is no need in copy-paste and
hardcore optimization there. You can extend the default <a href="https://github.com/postcss/postcss/blob/master/lib/parser.es6">PostCSS parser</a>.</p>
<h3><a class="anchor" aria-hidden="true" id="node-source"></a><a href="#node-source" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Node Source</h3>
<p>Every node should have <code>source</code> property to generate correct source map.
This property contains <code>start</code> and <code>end</code> properties with <code>{ line, column }</code>,
and <code>input</code> property with an <a href="https://github.com/postcss/postcss/blob/master/lib/input.es6"><code>Input</code></a> instance.</p>
<p>Your tokenizer should save the original position so that you can propagate
the values to the parser, to ensure that the source map is correctly updated.</p>
<h3><a class="anchor" aria-hidden="true" id="raw-values"></a><a href="#raw-values" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Raw Values</h3>
<p>A good PostCSS parser should provide all information (including spaces symbols)
to generate byte-to-byte equal output. It is not so difficult, but respectful
for user input and allow integration smoke tests.</p>
<p>A parser should save all additional symbols to <code>node.raws</code> object.
It is an open structure for you, you can add additional keys.
For example, <a href="https://github.com/postcss/postcss-scss">SCSS parser</a> saves comment types (<code>/* */</code> or <code>//</code>)
in <code>node.raws.inline</code>.</p>
<p>The default parser cleans CSS values from comments and spaces.
It saves the original value with comments to <code>node.raws.value.raw</code> and uses it,
if the node value was not changed.</p>
<h3><a class="anchor" aria-hidden="true" id="tests"></a><a href="#tests" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Tests</h3>
<p>Of course, all parsers in the PostCSS ecosystem must have tests.</p>
<p>If your parser just extends CSS syntax (like <a href="https://github.com/postcss/postcss-scss">SCSS</a> or <a href="https://github.com/postcss/postcss-safe-parser">Safe Parser</a>),
you can use the <a href="https://github.com/postcss/postcss-parser-tests">PostCSS Parser Tests</a>. It contains unit &amp; integration tests.</p>
<h2><a class="anchor" aria-hidden="true" id="stringifier"></a><a href="#stringifier" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Stringifier</h2>
<p>A style guide generator is a good example of a stringifier. It generates output
HTML which contains CSS components. For this use case, a parser isn't necessary,
so the package should just contain a stringifier.</p>
<p>The Stringifier API is little bit more complicated, than the parser API.
PostCSS generates a source map, so a stringifier can’t just return a string.
It must link every substring with its source node.</p>
<p>A Stringifier is a function which receives <a href="http://api.postcss.org/Root.html"><code>Root</code></a> node and builder callback.
Then it calls builder with every node’s string and node instance.</p>
<pre><code class="hljs css language-js"><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">stringify</span> (<span class="hljs-params">root, builder</span>) </span>{
  <span class="hljs-comment">// Some magic</span>
  <span class="hljs-keyword">const</span> string = decl.prop + <span class="hljs-string">':'</span> + decl.value + <span class="hljs-string">';'</span>
  builder(string, decl)
  <span class="hljs-comment">// Some science</span>
};
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="main-theory-1"></a><a href="#main-theory-1" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Main Theory</h3>
<p>PostCSS <a href="https://github.com/postcss/postcss/blob/master/lib/stringifier.es6">default stringifier</a> is just a class with a method for each node type
and many methods to detect raw properties.</p>
<p>In most cases it will be enough just to extend this class,
like in <a href="https://github.com/postcss/postcss-scss/blob/master/lib/scss-stringifier.es6">SCSS stringifier</a>.</p>
<h3><a class="anchor" aria-hidden="true" id="builder-function"></a><a href="#builder-function" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Builder Function</h3>
<p>A builder function will be passed to <code>stringify</code> function as second argument.
For example, the default PostCSS stringifier class saves it
to <code>this.builder</code> property.</p>
<p>Builder receives output substring and source node to append this substring
to the final output.</p>
<p>Some nodes contain other nodes in the middle. For example, a rule has a <code>{</code>
at the beginning, many declarations inside and a closing <code>}</code>.</p>
<p>For these cases, you should pass a third argument to builder function:
<code>'start'</code> or <code>'end'</code> string:</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">this</span>.builder(rule.selector + <span class="hljs-string">'{'</span>, rule, <span class="hljs-string">'start'</span>)
<span class="hljs-comment">// Stringify declarations inside</span>
<span class="hljs-keyword">this</span>.builder(<span class="hljs-string">'}'</span>, rule, <span class="hljs-string">'end'</span>)
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="raw-values-1"></a><a href="#raw-values-1" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Raw Values</h3>
<p>A good PostCSS custom syntax saves all symbols and provide byte-to-byte equal
output if there were no changes.</p>
<p>This is why every node has <code>node.raws</code> object to store space symbol, etc.</p>
<p>Be careful, because sometimes these raw properties will not be present; some
nodes may be built manually, or may lose their indentation when they are moved
to another parent node.</p>
<p>This is why the default stringifier has a <code>raw()</code> method to autodetect raw
properties by other nodes. For example, it will look at other nodes to detect
indent size and them multiply it with the current node depth.</p>
<h3><a class="anchor" aria-hidden="true" id="tests-1"></a><a href="#tests-1" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Tests</h3>
<p>A stringifier must have tests too.</p>
<p>You can use unit and integration test cases from <a href="https://github.com/postcss/postcss-parser-tests">PostCSS Parser Tests</a>.
Just compare input CSS with CSS after your parser and stringifier.</p>
</span></div></article></div><div class="docs-prevnext"></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#syntax">Syntax</a></li><li><a href="#parser">Parser</a><ul class="toc-headings"><li><a href="#main-theory">Main Theory</a></li><li><a href="#performance">Performance</a></li><li><a href="#node-source">Node Source</a></li><li><a href="#raw-values">Raw Values</a></li><li><a href="#tests">Tests</a></li></ul></li><li><a href="#stringifier">Stringifier</a><ul class="toc-headings"><li><a href="#main-theory-1">Main Theory</a></li><li><a href="#builder-function">Builder Function</a></li><li><a href="#raw-values-1">Raw Values</a></li><li><a href="#tests-1">Tests</a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/underbase/" class="nav-home"><img src="/underbase/img/logo.svg" alt="Underbase" width="66" height="58"/></a><div><h5>Docs</h5><a href="/underbase/docs/en/doc1.html">Getting Started (or other categories)</a><a href="/underbase/docs/en/doc2.html">Guides (or other categories)</a><a href="/underbase/docs/en/doc3.html">API Reference (or other categories)</a></div><div><h5>Community</h5><a href="https://stackoverflow.com/questions/tagged/" target="_blank" rel="noreferrer noopener">Stack Overflow</a><a href="https://discordapp.com/">Project Chat</a><a href="https://twitter.com/" target="_blank" rel="noreferrer noopener">Twitter</a></div><div><h5>More</h5><a href="/underbase/blog">Blog</a><a href="https://github.com/">GitHub</a><a class="github-button" data-icon="octicon-star" data-count-href="/facebook/docusaurus/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div></section></footer></div></body></html>