<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>node_modules/css-tree/docs/traversal · Underbase</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="&lt;h1&gt;&lt;a class=&quot;anchor&quot; aria-hidden=&quot;true&quot; id=&quot;ast-traversal&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#ast-traversal&quot; aria-hidden=&quot;true&quot; class=&quot;hash-link&quot;&gt;&lt;svg class=&quot;hash-link-icon&quot; aria-hidden=&quot;true&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;AST traversal&lt;/h1&gt;
"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="node_modules/css-tree/docs/traversal · Underbase"/><meta property="og:type" content="website"/><meta property="og:url" content="https://sundowndev.github.io/underbase/"/><meta property="og:description" content="&lt;h1&gt;&lt;a class=&quot;anchor&quot; aria-hidden=&quot;true&quot; id=&quot;ast-traversal&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#ast-traversal&quot; aria-hidden=&quot;true&quot; class=&quot;hash-link&quot;&gt;&lt;svg class=&quot;hash-link-icon&quot; aria-hidden=&quot;true&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;AST traversal&lt;/h1&gt;
"/><meta property="og:image" content="https://sundowndev.github.io/underbase/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://sundowndev.github.io/underbase/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/underbase/img/logo.svg"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="alternate" type="application/atom+xml" href="https://sundowndev.github.io/underbase/blog/atom.xml" title="Underbase Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://sundowndev.github.io/underbase/blog/feed.xml" title="Underbase Blog RSS Feed"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="/underbase/js/scrollSpy.js"></script><link rel="stylesheet" href="/underbase/css/main.css"/><script src="/underbase/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/underbase/"><img class="logo" src="/underbase/img/logo.svg" alt="Underbase"/><h2 class="headerTitleWithLogo">Underbase</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/underbase/docs/installation" target="_self">Guides</a></li><li class=""><a href="/underbase/docs/api" target="_self">API</a></li><li class=""><a href="/underbase/blog/" target="_self">Release notes</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle">node_modules/css-tree/docs/traversal</h1></header><article><div><span><h1><a class="anchor" aria-hidden="true" id="ast-traversal"></a><a href="#ast-traversal" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>AST traversal</h1>
<p>AST traversal API is provided by <code>walk()</code> method.</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">var</span> csstree = <span class="hljs-built_in">require</span>(<span class="hljs-string">'css-tree'</span>);
<span class="hljs-keyword">var</span> ast = csstree.parse(<span class="hljs-string">'.a { color: red; }'</span>);

csstree.walk(ast, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
    <span class="hljs-built_in">console</span>.log(node.type);
});
<span class="hljs-comment">// StyleSheet</span>
<span class="hljs-comment">// Rule</span>
<span class="hljs-comment">// SelectorList</span>
<span class="hljs-comment">// Selector</span>
<span class="hljs-comment">// ClassSelector</span>
<span class="hljs-comment">// Block</span>
<span class="hljs-comment">// Declaration</span>
<span class="hljs-comment">// Value</span>
<span class="hljs-comment">// Identifier</span>
</code></pre>
<p>The facts you should know about <code>walk()</code> internals:</p>
<ul>
<li>Method uses <code>structure</code> field value of every node type to define the way how to iterate the nodes:
<ul>
<li>A function-iterator is generating for every node type.</li>
<li>Node's properties iterates in the order it defined in <code>structure</code> (<a href="#reverse">reverse</a> option can invert an order).</li>
<li>Properties that are not defined in <code>structure</code> are ignoring (doesn't interate).</li>
<li>An exception is possible when a tree is not following to expected structure (it may happen if AST was built outside the CSSTree parser or transformed in a wrong way). In case you are not sure about correctness of a tree structure, you can use <code>try/catch</code> or check the tree with <code>csstree.lexer.validateStructure(ast)</code> before iterate it.</li>
</ul></li>
<li>Only <code>children</code> fields can contain a list of nodes. A list of nodes should be represented as a <code>List</code> instances. But for certain cases, <code>children</code> can be an array. Since <code>List</code> provides a similar to <code>Array</code> API, traversal can work in most cases, but without any guarantee. Therefore usings arrays in AST is not recomended, use them on your own risk.</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="walkast-options"></a><a href="#walkast-options" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>walk(ast, options)</h2>
<p>Method visits each node of passed tree in a natural way and calls a handler for each one. It takes two arguments: a root node (<code>ast</code>) and an object (<code>options</code>). In simple case, it can take a function (handler) instead of <code>options</code> (<code>walk(ast, fn)</code> is equivalent to <code>walk(ast, { enter: fn })</code>).</p>
<p>Options:</p>
<!-- MarkdownTOC -->
<ul>
<li><a href="#enter">enter</a></li>
<li><a href="#leave">leave</a></li>
<li><a href="#visit">visit</a></li>
<li><a href="#reverse">reverse</a></li>
</ul>
<!-- /MarkdownTOC -->
<h3><a class="anchor" aria-hidden="true" id="enter"></a><a href="#enter" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>enter</h3>
<p>Type: <code>function</code> or <code>undefined</code>  <br>
Default: <code>undefined</code></p>
<p>Handler on node entrance, i.e. before any nested node is processed.</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">var</span> csstree = <span class="hljs-built_in">require</span>(<span class="hljs-string">'css-tree'</span>);
<span class="hljs-keyword">var</span> ast = csstree.parse(<span class="hljs-string">'.a { color: red; }'</span>);

csstree.walk(ast, {
    <span class="hljs-attr">enter</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
        <span class="hljs-built_in">console</span>.log(node.type);
    }
});
<span class="hljs-comment">// StyleSheet</span>
<span class="hljs-comment">// Rule</span>
<span class="hljs-comment">// SelectorList</span>
<span class="hljs-comment">// Selector</span>
<span class="hljs-comment">// ClassSelector</span>
<span class="hljs-comment">// Block</span>
<span class="hljs-comment">// Declaration</span>
<span class="hljs-comment">// Value</span>
<span class="hljs-comment">// Identifier</span>
</code></pre>
<p>In case <code>options</code> has a single <code>enter</code> field, it can replaced for the handler passed as a value for <code>enter</code>, i.e. <code>walk(ast, { enter: fn })</code> → <code>walk(ast, fn)</code>.</p>
<p>Handler receives a three arguments:</p>
<ul>
<li><code>node</code> – the AST node a walker entering to</li>
<li><code>item</code> – node wrapper, that contains references to <code>prev</code> and <code>next</code> nodes in a list, and <code>data</code> reference for the node</li>
<li><code>list</code> – is a reference for the list; it's useful for list operations like <code>remove()</code> or <code>insert()</code></li>
</ul>
<blockquote>
<p>NOTE: If <code>children</code> is an array, the last two arguments are <code>index</code> and <code>array</code>, like for <code>Array#forEach()</code> or <code>Array#map()</code> methods.</p>
</blockquote>
<pre><code class="hljs css language-js"><span class="hljs-keyword">const</span> csstree = <span class="hljs-built_in">require</span>(<span class="hljs-string">'css-tree'</span>);
<span class="hljs-keyword">const</span> ast = csstree.parse(<span class="hljs-string">`
    .a { foo: 1; bar: 2; }
    .b { bar: 3; baz: 4; }
`</span>);

<span class="hljs-comment">// remove declarations with `bar` property from the tree</span>
csstree.walk(ast, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, item, list</span>) </span>{
    <span class="hljs-keyword">if</span> (node.type === <span class="hljs-string">'Declaration'</span> &amp;&amp; node.property === <span class="hljs-string">'bar'</span> &amp;&amp; list) {
        <span class="hljs-comment">// remove a declaration from a list it</span>
        list.remove(item);
    }
});

<span class="hljs-built_in">console</span>.log(csstree.generate(ast));
<span class="hljs-comment">// .a{foo:1}.b{baz:4}</span>
</code></pre>
<blockquote>
<p>NOTE:</p>
<ul>
<li><code>item</code> and <code>list</code> are not defined for nodes that are not in a list. Even <code>Declaration</code> can be outside of any list in case it is a root of tree or a part of <code>@supports</code> prelude, e.g. <code>@supports (bar: 123) { ... }</code>. Therefore, it's recomended to check <code>item</code> or <code>list</code> are defined before using of it (those values both are defined or both are undefined, so it's enough to test one of them)</li>
<li>Only <code>List</code> instances are safe for tree transformations such as node removal. In case you perform such operations, you can ensure that all <code>children</code> in a tree is a <code>List</code> instances by calling <code>csstree.fromPlainObject(ast)</code> before traversal.</li>
<li>It's better to use <code>visit</code> option when possible to reach better performance</li>
</ul>
</blockquote>
<p>Context (<code>this</code>) for a handler is an object with a references to the closest ancestor nodes:</p>
<ul>
<li><code>root</code> – refers to AST root node (actually it's a node passed to <code>walk()</code> method)</li>
<li><code>stylesheet</code> – refers to <code>StyleSheet</code> node, usually it's a root node</li>
<li><code>atrule</code> – refers to closest <code>Atrule</code> node if any</li>
<li><code>atrulePrelude</code> – refers to <code>AtrulePrelude</code> node if any</li>
<li><code>rule</code> – refers to closest <code>Rule</code> node if any</li>
<li><code>selector</code> – refers to <code>SelectorList</code> node if any</li>
<li><code>block</code> - refers to closest <code>Block</code> node if any</li>
<li><code>declaration</code> – refers to <code>Declaration</code> node if any</li>
<li><code>function</code> – refers to closest <code>Function</code>, <code>PseudoClassSelector</code> or <code>PseudoElementSelector</code> node if current node inside one of them</li>
</ul>
<pre><code class="hljs css language-js"><span class="hljs-keyword">const</span> csstree = <span class="hljs-built_in">require</span>(<span class="hljs-string">'css-tree'</span>);
<span class="hljs-keyword">const</span> ast = csstree.parse(<span class="hljs-string">`
    @import url(import.css);
    .foo { background: url('foo.jpg'); }
    .bar { background-image: url(bar.png); }
`</span>);

<span class="hljs-comment">// collect all urls in declarations</span>
<span class="hljs-keyword">const</span> urls = [];
csstree.walk(ast, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.declaration !== <span class="hljs-literal">null</span> &amp;&amp; node.type === <span class="hljs-string">'Url'</span>) {
        <span class="hljs-keyword">const</span> value = node.value;

        <span class="hljs-keyword">if</span> (value.type === <span class="hljs-string">'Raw'</span>) {
            urls.push(value.value);
        } <span class="hljs-keyword">else</span> {
            urls.push(value.value.substr(<span class="hljs-number">1</span>, value.value.length - <span class="hljs-number">2</span>));
        }
    }
});

<span class="hljs-built_in">console</span>.log(urls);
<span class="hljs-comment">// [ 'foo.jpg', 'bar.png' ]</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="leave"></a><a href="#leave" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>leave</h3>
<p>Type: <code>function</code> or <code>undefined</code>  <br>
Default: <code>undefined</code></p>
<p>The same as <code>enter</code> handler but invokes on node exit, i.e. after all nested nodes are processed.</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">var</span> csstree = <span class="hljs-built_in">require</span>(<span class="hljs-string">'css-tree'</span>);
<span class="hljs-keyword">var</span> ast = csstree.parse(<span class="hljs-string">'.a { color: red; }'</span>);

csstree.walk(ast, {
    <span class="hljs-attr">leave</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
        <span class="hljs-built_in">console</span>.log(node.type);
    }
});
<span class="hljs-comment">// ClassSelector</span>
<span class="hljs-comment">// Selector</span>
<span class="hljs-comment">// SelectorList</span>
<span class="hljs-comment">// Identifier</span>
<span class="hljs-comment">// Value</span>
<span class="hljs-comment">// Declaration</span>
<span class="hljs-comment">// Block</span>
<span class="hljs-comment">// Rule</span>
<span class="hljs-comment">// StyleSheet</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="visit"></a><a href="#visit" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>visit</h3>
<p>Type: <code>string</code> or <code>null</code>  <br>
Default: <code>null</code></p>
<p>Invokes a handler for a specified node type only.</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">var</span> csstree = <span class="hljs-built_in">require</span>(<span class="hljs-string">'css-tree'</span>);
<span class="hljs-keyword">var</span> ast = csstree.parse(<span class="hljs-string">'.a { color: red; } .b { color: green; }'</span>);

csstree.walk(ast, {
    <span class="hljs-attr">visit</span>: <span class="hljs-string">'ClassSelector'</span>,
    <span class="hljs-attr">enter</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
        <span class="hljs-built_in">console</span>.log(node.name);
    }
});

<span class="hljs-comment">// example above is equal to</span>
csstree.walk(ast, {
    <span class="hljs-attr">enter</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">if</span> (node.type === <span class="hljs-string">'ClassSelector'</span>) {
            <span class="hljs-built_in">console</span>.log(node.name);
        }
    }
});
</code></pre>
<p>The traveral for some node types can performs faster (10-15 times depending on the CSS structure), because some subtrees may to be skipped since they can't contain a node of specified type (e.g. <code>Rule</code> can't be used inside of <code>Declaration</code>, so declaration's subtree can be exclude from traversal path). Fast traversal is supported for node types:</p>
<ul>
<li><code>Atrule</code></li>
<li><code>Rule</code></li>
<li><code>Declaration</code></li>
</ul>
<blockquote>
<p>NOTE: When fast traversal is applied, some nodes may not be reached in case of an incorrect location in the tree. That's may happen if AST was built outside the CSSTree parser or transformed in a wrong way. If you need to be 100% sure that every node of type will be visited (even in wrong position), don't use <code>visit</code> option and test node type by your own.</p>
</blockquote>
<h3><a class="anchor" aria-hidden="true" id="reverse"></a><a href="#reverse" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>reverse</h3>
<p>Type: <code>boolean</code>  <br>
Default: <code>false</code></p>
<p>Inverts a natural order of traversal of nodes. To achieve this, the following actions are performed:</p>
<ul>
<li>children nodes are iterated in reverse order (from last to first)</li>
<li>properties are iterated in reverse order (according to <code>structure</code> definition of node)</li>
<li><code>enter</code> and <code>leave</code> handlers are swapped</li>
</ul>
<pre><code class="hljs css language-js"><span class="hljs-keyword">var</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">'assert'</span>);
<span class="hljs-keyword">var</span> csstree = <span class="hljs-built_in">require</span>(<span class="hljs-string">'css-tree'</span>);
<span class="hljs-keyword">var</span> ast = csstree.parse(<span class="hljs-string">'.a { color: red; }'</span>);

<span class="hljs-keyword">var</span> natural = [];
csstree.walk(ast, {
    <span class="hljs-attr">enter</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
        natural.push(<span class="hljs-string">'enter '</span> + node.type);
    },
    <span class="hljs-attr">leave</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
        natural.push(<span class="hljs-string">'leave '</span> + node.type);
    }
});

<span class="hljs-keyword">var</span> reverse = [];
csstree.walk(ast, {
    <span class="hljs-attr">reverse</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">enter</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
        reverse.push(<span class="hljs-string">'enter '</span> + node.type);
    },
    <span class="hljs-attr">leave</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
        reverse.push(<span class="hljs-string">'leave '</span> + node.type);
    }
});

<span class="hljs-comment">// will be truthy</span>
assert.deepEqual(
    reverse,
    natural.reverse()
);
</code></pre>
</span></div></article></div><div class="docs-prevnext"></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#walkast-options">walk(ast, options)</a><ul class="toc-headings"><li><a href="#enter">enter</a></li><li><a href="#leave">leave</a></li><li><a href="#visit">visit</a></li><li><a href="#reverse">reverse</a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/underbase/" class="nav-home"><img src="/underbase/img/logo.svg" alt="Underbase" width="66" height="58"/></a><div><h5>Docs</h5><a href="/underbase/docs/en/doc1.html">Getting Started (or other categories)</a><a href="/underbase/docs/en/doc2.html">Guides (or other categories)</a><a href="/underbase/docs/en/doc3.html">API Reference (or other categories)</a></div><div><h5>Community</h5><a href="https://stackoverflow.com/questions/tagged/" target="_blank" rel="noreferrer noopener">Stack Overflow</a><a href="https://discordapp.com/">Project Chat</a><a href="https://twitter.com/" target="_blank" rel="noreferrer noopener">Twitter</a></div><div><h5>More</h5><a href="/underbase/blog">Blog</a><a href="https://github.com/">GitHub</a><a class="github-button" data-icon="octicon-star" data-count-href="/facebook/docusaurus/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div></section></footer></div></body></html>