<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>node_modules/qs/README · Underbase</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="&lt;h1&gt;&lt;a class=&quot;anchor&quot; aria-hidden=&quot;true&quot; id=&quot;qs-sup-version-badge-2-1-sup&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#qs-sup-version-badge-2-1-sup&quot; aria-hidden=&quot;true&quot; class=&quot;hash-link&quot;&gt;&lt;svg class=&quot;hash-link-icon&quot; aria-hidden=&quot;true&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;qs &lt;sup&gt;[![Version Badge][2]][1]&lt;/sup&gt;&lt;/h1&gt;
"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="node_modules/qs/README · Underbase"/><meta property="og:type" content="website"/><meta property="og:url" content="https://sundowndev.github.io/underbase/"/><meta property="og:description" content="&lt;h1&gt;&lt;a class=&quot;anchor&quot; aria-hidden=&quot;true&quot; id=&quot;qs-sup-version-badge-2-1-sup&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#qs-sup-version-badge-2-1-sup&quot; aria-hidden=&quot;true&quot; class=&quot;hash-link&quot;&gt;&lt;svg class=&quot;hash-link-icon&quot; aria-hidden=&quot;true&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;qs &lt;sup&gt;[![Version Badge][2]][1]&lt;/sup&gt;&lt;/h1&gt;
"/><meta property="og:image" content="https://sundowndev.github.io/underbase/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://sundowndev.github.io/underbase/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/underbase/img/logo.svg"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="alternate" type="application/atom+xml" href="https://sundowndev.github.io/underbase/blog/atom.xml" title="Underbase Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://sundowndev.github.io/underbase/blog/feed.xml" title="Underbase Blog RSS Feed"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="/underbase/js/scrollSpy.js"></script><link rel="stylesheet" href="/underbase/css/main.css"/><script src="/underbase/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/underbase/"><img class="logo" src="/underbase/img/logo.svg" alt="Underbase"/><h2 class="headerTitleWithLogo">Underbase</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/underbase/docs/installation" target="_self">Guides</a></li><li class=""><a href="/underbase/docs/api" target="_self">API</a></li><li class=""><a href="/underbase/blog/" target="_self">Release notes</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle">node_modules/qs/README</h1></header><article><div><span><h1><a class="anchor" aria-hidden="true" id="qs-sup-version-badge-2-1-sup"></a><a href="#qs-sup-version-badge-2-1-sup" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>qs <sup><a href="https://npmjs.org/package/qs">![Version Badge][2]</a></sup></h1>
<p><a href="https://travis-ci.org/ljharb/qs">![Build Status][3]</a>
<a href="https://david-dm.org/ljharb/qs">![dependency status][5]</a>
<a href="https://david-dm.org/ljharb/qs?type=dev">![dev dependency status][7]</a>
<a href="LICENSE">![License][license-image]</a>
<a href="http://npm-stat.com/charts.html?package=qs">![Downloads][downloads-image]</a></p>
<p><a href="https://npmjs.org/package/qs">![npm badge][11]</a></p>
<p>A querystring parsing and stringifying library with some added security.</p>
<p>Lead Maintainer: <a href="https://github.com/ljharb">Jordan Harband</a></p>
<p>The <strong>qs</strong> module was originally created and maintained by <a href="https://github.com/visionmedia/node-querystring">TJ Holowaychuk</a>.</p>
<h2><a class="anchor" aria-hidden="true" id="usage"></a><a href="#usage" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Usage</h2>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">var</span> qs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'qs'</span>);
<span class="hljs-keyword">var</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">'assert'</span>);

<span class="hljs-keyword">var</span> obj = qs.parse(<span class="hljs-string">'a=c'</span>);
assert.deepEqual(obj, { <span class="hljs-attr">a</span>: <span class="hljs-string">'c'</span> });

<span class="hljs-keyword">var</span> str = qs.stringify(obj);
assert.equal(str, <span class="hljs-string">'a=c'</span>);
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="parsing-objects"></a><a href="#parsing-objects" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Parsing Objects</h3>
<p><a href="#preventEval"></a></p>
<pre><code class="hljs css language-javascript">qs.parse(string, [options]);
</code></pre>
<p><strong>qs</strong> allows you to create nested objects within your query strings, by surrounding the name of sub-keys with square brackets <code>[]</code>.
For example, the string <code>'foo[bar]=baz'</code> converts to:</p>
<pre><code class="hljs css language-javascript">assert.deepEqual(qs.parse(<span class="hljs-string">'foo[bar]=baz'</span>), {
    <span class="hljs-attr">foo</span>: {
        <span class="hljs-attr">bar</span>: <span class="hljs-string">'baz'</span>
    }
});
</code></pre>
<p>When using the <code>plainObjects</code> option the parsed value is returned as a null object, created via <code>Object.create(null)</code> and as such you should be aware that prototype methods will not exist on it and a user may set those names to whatever value they like:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">var</span> nullObject = qs.parse(<span class="hljs-string">'a[hasOwnProperty]=b'</span>, { <span class="hljs-attr">plainObjects</span>: <span class="hljs-literal">true</span> });
assert.deepEqual(nullObject, { <span class="hljs-attr">a</span>: { <span class="hljs-attr">hasOwnProperty</span>: <span class="hljs-string">'b'</span> } });
</code></pre>
<p>By default parameters that would overwrite properties on the object prototype are ignored, if you wish to keep the data from those fields either use <code>plainObjects</code> as mentioned above, or set <code>allowPrototypes</code> to <code>true</code> which will allow user input to overwrite those properties. <em>WARNING</em> It is generally a bad idea to enable this option as it can cause problems when attempting to use the properties that have been overwritten. Always be careful with this option.</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">var</span> protoObject = qs.parse(<span class="hljs-string">'a[hasOwnProperty]=b'</span>, { <span class="hljs-attr">allowPrototypes</span>: <span class="hljs-literal">true</span> });
assert.deepEqual(protoObject, { <span class="hljs-attr">a</span>: { <span class="hljs-attr">hasOwnProperty</span>: <span class="hljs-string">'b'</span> } });
</code></pre>
<p>URI encoded strings work too:</p>
<pre><code class="hljs css language-javascript">assert.deepEqual(qs.parse(<span class="hljs-string">'a%5Bb%5D=c'</span>), {
    <span class="hljs-attr">a</span>: { <span class="hljs-attr">b</span>: <span class="hljs-string">'c'</span> }
});
</code></pre>
<p>You can also nest your objects, like <code>'foo[bar][baz]=foobarbaz'</code>:</p>
<pre><code class="hljs css language-javascript">assert.deepEqual(qs.parse(<span class="hljs-string">'foo[bar][baz]=foobarbaz'</span>), {
    <span class="hljs-attr">foo</span>: {
        <span class="hljs-attr">bar</span>: {
            <span class="hljs-attr">baz</span>: <span class="hljs-string">'foobarbaz'</span>
        }
    }
});
</code></pre>
<p>By default, when nesting objects <strong>qs</strong> will only parse up to 5 children deep. This means if you attempt to parse a string like
<code>'a[b][c][d][e][f][g][h][i]=j'</code> your resulting object will be:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">var</span> expected = {
    <span class="hljs-attr">a</span>: {
        <span class="hljs-attr">b</span>: {
            <span class="hljs-attr">c</span>: {
                <span class="hljs-attr">d</span>: {
                    <span class="hljs-attr">e</span>: {
                        <span class="hljs-attr">f</span>: {
                            <span class="hljs-string">'[g][h][i]'</span>: <span class="hljs-string">'j'</span>
                        }
                    }
                }
            }
        }
    }
};
<span class="hljs-keyword">var</span> string = <span class="hljs-string">'a[b][c][d][e][f][g][h][i]=j'</span>;
assert.deepEqual(qs.parse(string), expected);
</code></pre>
<p>This depth can be overridden by passing a <code>depth</code> option to <code>qs.parse(string, [options])</code>:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">var</span> deep = qs.parse(<span class="hljs-string">'a[b][c][d][e][f][g][h][i]=j'</span>, { <span class="hljs-attr">depth</span>: <span class="hljs-number">1</span> });
assert.deepEqual(deep, { <span class="hljs-attr">a</span>: { <span class="hljs-attr">b</span>: { <span class="hljs-string">'[c][d][e][f][g][h][i]'</span>: <span class="hljs-string">'j'</span> } } });
</code></pre>
<p>The depth limit helps mitigate abuse when <strong>qs</strong> is used to parse user input, and it is recommended to keep it a reasonably small number.</p>
<p>For similar reasons, by default <strong>qs</strong> will only parse up to 1000 parameters. This can be overridden by passing a <code>parameterLimit</code> option:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">var</span> limited = qs.parse(<span class="hljs-string">'a=b&amp;c=d'</span>, { <span class="hljs-attr">parameterLimit</span>: <span class="hljs-number">1</span> });
assert.deepEqual(limited, { <span class="hljs-attr">a</span>: <span class="hljs-string">'b'</span> });
</code></pre>
<p>To bypass the leading question mark, use <code>ignoreQueryPrefix</code>:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">var</span> prefixed = qs.parse(<span class="hljs-string">'?a=b&amp;c=d'</span>, { <span class="hljs-attr">ignoreQueryPrefix</span>: <span class="hljs-literal">true</span> });
assert.deepEqual(prefixed, { <span class="hljs-attr">a</span>: <span class="hljs-string">'b'</span>, <span class="hljs-attr">c</span>: <span class="hljs-string">'d'</span> });
</code></pre>
<p>An optional delimiter can also be passed:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">var</span> delimited = qs.parse(<span class="hljs-string">'a=b;c=d'</span>, { <span class="hljs-attr">delimiter</span>: <span class="hljs-string">';'</span> });
assert.deepEqual(delimited, { <span class="hljs-attr">a</span>: <span class="hljs-string">'b'</span>, <span class="hljs-attr">c</span>: <span class="hljs-string">'d'</span> });
</code></pre>
<p>Delimiters can be a regular expression too:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">var</span> regexed = qs.parse(<span class="hljs-string">'a=b;c=d,e=f'</span>, { <span class="hljs-attr">delimiter</span>: <span class="hljs-regexp">/[;,]/</span> });
assert.deepEqual(regexed, { <span class="hljs-attr">a</span>: <span class="hljs-string">'b'</span>, <span class="hljs-attr">c</span>: <span class="hljs-string">'d'</span>, <span class="hljs-attr">e</span>: <span class="hljs-string">'f'</span> });
</code></pre>
<p>Option <code>allowDots</code> can be used to enable dot notation:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">var</span> withDots = qs.parse(<span class="hljs-string">'a.b=c'</span>, { <span class="hljs-attr">allowDots</span>: <span class="hljs-literal">true</span> });
assert.deepEqual(withDots, { <span class="hljs-attr">a</span>: { <span class="hljs-attr">b</span>: <span class="hljs-string">'c'</span> } });
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="parsing-arrays"></a><a href="#parsing-arrays" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Parsing Arrays</h3>
<p><strong>qs</strong> can also parse arrays using a similar <code>[]</code> notation:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">var</span> withArray = qs.parse(<span class="hljs-string">'a[]=b&amp;a[]=c'</span>);
assert.deepEqual(withArray, { <span class="hljs-attr">a</span>: [<span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>] });
</code></pre>
<p>You may specify an index as well:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">var</span> withIndexes = qs.parse(<span class="hljs-string">'a[1]=c&amp;a[0]=b'</span>);
assert.deepEqual(withIndexes, { <span class="hljs-attr">a</span>: [<span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>] });
</code></pre>
<p>Note that the only difference between an index in an array and a key in an object is that the value between the brackets must be a number
to create an array. When creating arrays with specific indices, <strong>qs</strong> will compact a sparse array to only the existing values preserving
their order:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">var</span> noSparse = qs.parse(<span class="hljs-string">'a[1]=b&amp;a[15]=c'</span>);
assert.deepEqual(noSparse, { <span class="hljs-attr">a</span>: [<span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>] });
</code></pre>
<p>Note that an empty string is also a value, and will be preserved:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">var</span> withEmptyString = qs.parse(<span class="hljs-string">'a[]=&amp;a[]=b'</span>);
assert.deepEqual(withEmptyString, { <span class="hljs-attr">a</span>: [<span class="hljs-string">''</span>, <span class="hljs-string">'b'</span>] });

<span class="hljs-keyword">var</span> withIndexedEmptyString = qs.parse(<span class="hljs-string">'a[0]=b&amp;a[1]=&amp;a[2]=c'</span>);
assert.deepEqual(withIndexedEmptyString, { <span class="hljs-attr">a</span>: [<span class="hljs-string">'b'</span>, <span class="hljs-string">''</span>, <span class="hljs-string">'c'</span>] });
</code></pre>
<p><strong>qs</strong> will also limit specifying indices in an array to a maximum index of <code>20</code>. Any array members with an index of greater than <code>20</code> will
instead be converted to an object with the index as the key:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">var</span> withMaxIndex = qs.parse(<span class="hljs-string">'a[100]=b'</span>);
assert.deepEqual(withMaxIndex, { <span class="hljs-attr">a</span>: { <span class="hljs-string">'100'</span>: <span class="hljs-string">'b'</span> } });
</code></pre>
<p>This limit can be overridden by passing an <code>arrayLimit</code> option:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">var</span> withArrayLimit = qs.parse(<span class="hljs-string">'a[1]=b'</span>, { <span class="hljs-attr">arrayLimit</span>: <span class="hljs-number">0</span> });
assert.deepEqual(withArrayLimit, { <span class="hljs-attr">a</span>: { <span class="hljs-string">'1'</span>: <span class="hljs-string">'b'</span> } });
</code></pre>
<p>To disable array parsing entirely, set <code>parseArrays</code> to <code>false</code>.</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">var</span> noParsingArrays = qs.parse(<span class="hljs-string">'a[]=b'</span>, { <span class="hljs-attr">parseArrays</span>: <span class="hljs-literal">false</span> });
assert.deepEqual(noParsingArrays, { <span class="hljs-attr">a</span>: { <span class="hljs-string">'0'</span>: <span class="hljs-string">'b'</span> } });
</code></pre>
<p>If you mix notations, <strong>qs</strong> will merge the two items into an object:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">var</span> mixedNotation = qs.parse(<span class="hljs-string">'a[0]=b&amp;a[b]=c'</span>);
assert.deepEqual(mixedNotation, { <span class="hljs-attr">a</span>: { <span class="hljs-string">'0'</span>: <span class="hljs-string">'b'</span>, <span class="hljs-attr">b</span>: <span class="hljs-string">'c'</span> } });
</code></pre>
<p>You can also create arrays of objects:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">var</span> arraysOfObjects = qs.parse(<span class="hljs-string">'a[][b]=c'</span>);
assert.deepEqual(arraysOfObjects, { <span class="hljs-attr">a</span>: [{ <span class="hljs-attr">b</span>: <span class="hljs-string">'c'</span> }] });
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="stringifying"></a><a href="#stringifying" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Stringifying</h3>
<p><a href="#preventEval"></a></p>
<pre><code class="hljs css language-javascript">qs.stringify(object, [options]);
</code></pre>
<p>When stringifying, <strong>qs</strong> by default URI encodes output. Objects are stringified as you would expect:</p>
<pre><code class="hljs css language-javascript">assert.equal(qs.stringify({ <span class="hljs-attr">a</span>: <span class="hljs-string">'b'</span> }), <span class="hljs-string">'a=b'</span>);
assert.equal(qs.stringify({ <span class="hljs-attr">a</span>: { <span class="hljs-attr">b</span>: <span class="hljs-string">'c'</span> } }), <span class="hljs-string">'a%5Bb%5D=c'</span>);
</code></pre>
<p>This encoding can be disabled by setting the <code>encode</code> option to <code>false</code>:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">var</span> unencoded = qs.stringify({ <span class="hljs-attr">a</span>: { <span class="hljs-attr">b</span>: <span class="hljs-string">'c'</span> } }, { <span class="hljs-attr">encode</span>: <span class="hljs-literal">false</span> });
assert.equal(unencoded, <span class="hljs-string">'a[b]=c'</span>);
</code></pre>
<p>Encoding can be disabled for keys by setting the <code>encodeValuesOnly</code> option to <code>true</code>:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">var</span> encodedValues = qs.stringify(
    { <span class="hljs-attr">a</span>: <span class="hljs-string">'b'</span>, <span class="hljs-attr">c</span>: [<span class="hljs-string">'d'</span>, <span class="hljs-string">'e=f'</span>], <span class="hljs-attr">f</span>: [[<span class="hljs-string">'g'</span>], [<span class="hljs-string">'h'</span>]] },
    { <span class="hljs-attr">encodeValuesOnly</span>: <span class="hljs-literal">true</span> }
);
assert.equal(encodedValues,<span class="hljs-string">'a=b&amp;c[0]=d&amp;c[1]=e%3Df&amp;f[0][0]=g&amp;f[1][0]=h'</span>);
</code></pre>
<p>This encoding can also be replaced by a custom encoding method set as <code>encoder</code> option:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">var</span> encoded = qs.stringify({ <span class="hljs-attr">a</span>: { <span class="hljs-attr">b</span>: <span class="hljs-string">'c'</span> } }, { <span class="hljs-attr">encoder</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">str</span>) </span>{
    <span class="hljs-comment">// Passed in values `a`, `b`, `c`</span>
    <span class="hljs-keyword">return</span> <span class="hljs-comment">// Return encoded string</span>
}})
</code></pre>
<p><em>(Note: the <code>encoder</code> option does not apply if <code>encode</code> is <code>false</code>)</em></p>
<p>Analogue to the <code>encoder</code> there is a <code>decoder</code> option for <code>parse</code> to override decoding of properties and values:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">var</span> decoded = qs.parse(<span class="hljs-string">'x=z'</span>, { <span class="hljs-attr">decoder</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">str</span>) </span>{
    <span class="hljs-comment">// Passed in values `x`, `z`</span>
    <span class="hljs-keyword">return</span> <span class="hljs-comment">// Return decoded string</span>
}})
</code></pre>
<p>Examples beyond this point will be shown as though the output is not URI encoded for clarity. Please note that the return values in these cases <em>will</em> be URI encoded during real usage.</p>
<p>When arrays are stringified, by default they are given explicit indices:</p>
<pre><code class="hljs css language-javascript">qs.stringify({ <span class="hljs-attr">a</span>: [<span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>] });
<span class="hljs-comment">// 'a[0]=b&amp;a[1]=c&amp;a[2]=d'</span>
</code></pre>
<p>You may override this by setting the <code>indices</code> option to <code>false</code>:</p>
<pre><code class="hljs css language-javascript">qs.stringify({ <span class="hljs-attr">a</span>: [<span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>] }, { <span class="hljs-attr">indices</span>: <span class="hljs-literal">false</span> });
<span class="hljs-comment">// 'a=b&amp;a=c&amp;a=d'</span>
</code></pre>
<p>You may use the <code>arrayFormat</code> option to specify the format of the output array:</p>
<pre><code class="hljs css language-javascript">qs.stringify({ <span class="hljs-attr">a</span>: [<span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>] }, { <span class="hljs-attr">arrayFormat</span>: <span class="hljs-string">'indices'</span> })
<span class="hljs-comment">// 'a[0]=b&amp;a[1]=c'</span>
qs.stringify({ <span class="hljs-attr">a</span>: [<span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>] }, { <span class="hljs-attr">arrayFormat</span>: <span class="hljs-string">'brackets'</span> })
<span class="hljs-comment">// 'a[]=b&amp;a[]=c'</span>
qs.stringify({ <span class="hljs-attr">a</span>: [<span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>] }, { <span class="hljs-attr">arrayFormat</span>: <span class="hljs-string">'repeat'</span> })
<span class="hljs-comment">// 'a=b&amp;a=c'</span>
</code></pre>
<p>When objects are stringified, by default they use bracket notation:</p>
<pre><code class="hljs css language-javascript">qs.stringify({ <span class="hljs-attr">a</span>: { <span class="hljs-attr">b</span>: { <span class="hljs-attr">c</span>: <span class="hljs-string">'d'</span>, <span class="hljs-attr">e</span>: <span class="hljs-string">'f'</span> } } });
<span class="hljs-comment">// 'a[b][c]=d&amp;a[b][e]=f'</span>
</code></pre>
<p>You may override this to use dot notation by setting the <code>allowDots</code> option to <code>true</code>:</p>
<pre><code class="hljs css language-javascript">qs.stringify({ <span class="hljs-attr">a</span>: { <span class="hljs-attr">b</span>: { <span class="hljs-attr">c</span>: <span class="hljs-string">'d'</span>, <span class="hljs-attr">e</span>: <span class="hljs-string">'f'</span> } } }, { <span class="hljs-attr">allowDots</span>: <span class="hljs-literal">true</span> });
<span class="hljs-comment">// 'a.b.c=d&amp;a.b.e=f'</span>
</code></pre>
<p>Empty strings and null values will omit the value, but the equals sign (=) remains in place:</p>
<pre><code class="hljs css language-javascript">assert.equal(qs.stringify({ <span class="hljs-attr">a</span>: <span class="hljs-string">''</span> }), <span class="hljs-string">'a='</span>);
</code></pre>
<p>Key with no values (such as an empty object or array) will return nothing:</p>
<pre><code class="hljs css language-javascript">assert.equal(qs.stringify({ <span class="hljs-attr">a</span>: [] }), <span class="hljs-string">''</span>);
assert.equal(qs.stringify({ <span class="hljs-attr">a</span>: {} }), <span class="hljs-string">''</span>);
assert.equal(qs.stringify({ <span class="hljs-attr">a</span>: [{}] }), <span class="hljs-string">''</span>);
assert.equal(qs.stringify({ <span class="hljs-attr">a</span>: { <span class="hljs-attr">b</span>: []} }), <span class="hljs-string">''</span>);
assert.equal(qs.stringify({ <span class="hljs-attr">a</span>: { <span class="hljs-attr">b</span>: {}} }), <span class="hljs-string">''</span>);
</code></pre>
<p>Properties that are set to <code>undefined</code> will be omitted entirely:</p>
<pre><code class="hljs css language-javascript">assert.equal(qs.stringify({ <span class="hljs-attr">a</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">b</span>: <span class="hljs-literal">undefined</span> }), <span class="hljs-string">'a='</span>);
</code></pre>
<p>The query string may optionally be prepended with a question mark:</p>
<pre><code class="hljs css language-javascript">assert.equal(qs.stringify({ <span class="hljs-attr">a</span>: <span class="hljs-string">'b'</span>, <span class="hljs-attr">c</span>: <span class="hljs-string">'d'</span> }, { <span class="hljs-attr">addQueryPrefix</span>: <span class="hljs-literal">true</span> }), <span class="hljs-string">'?a=b&amp;c=d'</span>);
</code></pre>
<p>The delimiter may be overridden with stringify as well:</p>
<pre><code class="hljs css language-javascript">assert.equal(qs.stringify({ <span class="hljs-attr">a</span>: <span class="hljs-string">'b'</span>, <span class="hljs-attr">c</span>: <span class="hljs-string">'d'</span> }, { <span class="hljs-attr">delimiter</span>: <span class="hljs-string">';'</span> }), <span class="hljs-string">'a=b;c=d'</span>);
</code></pre>
<p>If you only want to override the serialization of <code>Date</code> objects, you can provide a <code>serializeDate</code> option:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">var</span> date = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">7</span>);
assert.equal(qs.stringify({ <span class="hljs-attr">a</span>: date }), <span class="hljs-string">'a=1970-01-01T00:00:00.007Z'</span>.replace(<span class="hljs-regexp">/:/g</span>, <span class="hljs-string">'%3A'</span>));
assert.equal(
    qs.stringify({ <span class="hljs-attr">a</span>: date }, { <span class="hljs-attr">serializeDate</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">d</span>) </span>{ <span class="hljs-keyword">return</span> d.getTime(); } }),
    <span class="hljs-string">'a=7'</span>
);
</code></pre>
<p>You may use the <code>sort</code> option to affect the order of parameter keys:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">alphabeticalSort</span>(<span class="hljs-params">a, b</span>) </span>{
    <span class="hljs-keyword">return</span> a.localeCompare(b);
}
assert.equal(qs.stringify({ <span class="hljs-attr">a</span>: <span class="hljs-string">'c'</span>, <span class="hljs-attr">z</span>: <span class="hljs-string">'y'</span>, <span class="hljs-attr">b</span> : <span class="hljs-string">'f'</span> }, { <span class="hljs-attr">sort</span>: alphabeticalSort }), <span class="hljs-string">'a=c&amp;b=f&amp;z=y'</span>);
</code></pre>
<p>Finally, you can use the <code>filter</code> option to restrict which keys will be included in the stringified output.
If you pass a function, it will be called for each key to obtain the replacement value. Otherwise, if you
pass an array, it will be used to select properties and array indices for stringification:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">filterFunc</span>(<span class="hljs-params">prefix, value</span>) </span>{
    <span class="hljs-keyword">if</span> (prefix == <span class="hljs-string">'b'</span>) {
        <span class="hljs-comment">// Return an `undefined` value to omit a property.</span>
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-keyword">if</span> (prefix == <span class="hljs-string">'e[f]'</span>) {
        <span class="hljs-keyword">return</span> value.getTime();
    }
    <span class="hljs-keyword">if</span> (prefix == <span class="hljs-string">'e[g][0]'</span>) {
        <span class="hljs-keyword">return</span> value * <span class="hljs-number">2</span>;
    }
    <span class="hljs-keyword">return</span> value;
}
qs.stringify({ <span class="hljs-attr">a</span>: <span class="hljs-string">'b'</span>, <span class="hljs-attr">c</span>: <span class="hljs-string">'d'</span>, <span class="hljs-attr">e</span>: { <span class="hljs-attr">f</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">123</span>), <span class="hljs-attr">g</span>: [<span class="hljs-number">2</span>] } }, { <span class="hljs-attr">filter</span>: filterFunc });
<span class="hljs-comment">// 'a=b&amp;c=d&amp;e[f]=123&amp;e[g][0]=4'</span>
qs.stringify({ <span class="hljs-attr">a</span>: <span class="hljs-string">'b'</span>, <span class="hljs-attr">c</span>: <span class="hljs-string">'d'</span>, <span class="hljs-attr">e</span>: <span class="hljs-string">'f'</span> }, { <span class="hljs-attr">filter</span>: [<span class="hljs-string">'a'</span>, <span class="hljs-string">'e'</span>] });
<span class="hljs-comment">// 'a=b&amp;e=f'</span>
qs.stringify({ <span class="hljs-attr">a</span>: [<span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>], <span class="hljs-attr">e</span>: <span class="hljs-string">'f'</span> }, { <span class="hljs-attr">filter</span>: [<span class="hljs-string">'a'</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>] });
<span class="hljs-comment">// 'a[0]=b&amp;a[2]=d'</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="handling-of-null-values"></a><a href="#handling-of-null-values" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Handling of <code>null</code> values</h3>
<p>By default, <code>null</code> values are treated like empty strings:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">var</span> withNull = qs.stringify({ <span class="hljs-attr">a</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">b</span>: <span class="hljs-string">''</span> });
assert.equal(withNull, <span class="hljs-string">'a=&amp;b='</span>);
</code></pre>
<p>Parsing does not distinguish between parameters with and without equal signs. Both are converted to empty strings.</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">var</span> equalsInsensitive = qs.parse(<span class="hljs-string">'a&amp;b='</span>);
assert.deepEqual(equalsInsensitive, { <span class="hljs-attr">a</span>: <span class="hljs-string">''</span>, <span class="hljs-attr">b</span>: <span class="hljs-string">''</span> });
</code></pre>
<p>To distinguish between <code>null</code> values and empty strings use the <code>strictNullHandling</code> flag. In the result string the <code>null</code>
values have no <code>=</code> sign:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">var</span> strictNull = qs.stringify({ <span class="hljs-attr">a</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">b</span>: <span class="hljs-string">''</span> }, { <span class="hljs-attr">strictNullHandling</span>: <span class="hljs-literal">true</span> });
assert.equal(strictNull, <span class="hljs-string">'a&amp;b='</span>);
</code></pre>
<p>To parse values without <code>=</code> back to <code>null</code> use the <code>strictNullHandling</code> flag:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">var</span> parsedStrictNull = qs.parse(<span class="hljs-string">'a&amp;b='</span>, { <span class="hljs-attr">strictNullHandling</span>: <span class="hljs-literal">true</span> });
assert.deepEqual(parsedStrictNull, { <span class="hljs-attr">a</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">b</span>: <span class="hljs-string">''</span> });
</code></pre>
<p>To completely skip rendering keys with <code>null</code> values, use the <code>skipNulls</code> flag:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">var</span> nullsSkipped = qs.stringify({ <span class="hljs-attr">a</span>: <span class="hljs-string">'b'</span>, <span class="hljs-attr">c</span>: <span class="hljs-literal">null</span>}, { <span class="hljs-attr">skipNulls</span>: <span class="hljs-literal">true</span> });
assert.equal(nullsSkipped, <span class="hljs-string">'a=b'</span>);
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="dealing-with-special-character-sets"></a><a href="#dealing-with-special-character-sets" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Dealing with special character sets</h3>
<p>By default the encoding and decoding of characters is done in <code>utf-8</code>. If you
wish to encode querystrings to a different character set (i.e.
<a href="https://en.wikipedia.org/wiki/Shift_JIS">Shift JIS</a>) you can use the
<a href="https://github.com/martinheidegger/qs-iconv"><code>qs-iconv</code></a> library:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">var</span> encoder = <span class="hljs-built_in">require</span>(<span class="hljs-string">'qs-iconv/encoder'</span>)(<span class="hljs-string">'shift_jis'</span>);
<span class="hljs-keyword">var</span> shiftJISEncoded = qs.stringify({ <span class="hljs-attr">a</span>: <span class="hljs-string">'こんにちは！'</span> }, { <span class="hljs-attr">encoder</span>: encoder });
assert.equal(shiftJISEncoded, <span class="hljs-string">'a=%82%B1%82%F1%82%C9%82%BF%82%CD%81I'</span>);
</code></pre>
<p>This also works for decoding of query strings:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">var</span> decoder = <span class="hljs-built_in">require</span>(<span class="hljs-string">'qs-iconv/decoder'</span>)(<span class="hljs-string">'shift_jis'</span>);
<span class="hljs-keyword">var</span> obj = qs.parse(<span class="hljs-string">'a=%82%B1%82%F1%82%C9%82%BF%82%CD%81I'</span>, { <span class="hljs-attr">decoder</span>: decoder });
assert.deepEqual(obj, { <span class="hljs-attr">a</span>: <span class="hljs-string">'こんにちは！'</span> });
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="rfc-3986-and-rfc-1738-space-encoding"></a><a href="#rfc-3986-and-rfc-1738-space-encoding" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>RFC 3986 and RFC 1738 space encoding</h3>
<p>RFC3986 used as default option and encodes ' ' to <em>%20</em> which is backward compatible.
In the same time, output can be stringified as per RFC1738 with ' ' equal to '+'.</p>
<pre><code class="hljs"><span class="hljs-keyword">assert</span>.equal(qs.stringify({ <span class="hljs-string">a:</span> <span class="hljs-string">'b c'</span> }), <span class="hljs-string">'a=b%20c'</span>);
<span class="hljs-keyword">assert</span>.equal(qs.stringify({ <span class="hljs-string">a:</span> <span class="hljs-string">'b c'</span> }, { <span class="hljs-string">format :</span> <span class="hljs-string">'RFC3986'</span> }), <span class="hljs-string">'a=b%20c'</span>);
<span class="hljs-keyword">assert</span>.equal(qs.stringify({ <span class="hljs-string">a:</span> <span class="hljs-string">'b c'</span> }, { <span class="hljs-string">format :</span> <span class="hljs-string">'RFC1738'</span> }), <span class="hljs-string">'a=b+c'</span>);
</code></pre>
</span></div></article></div><div class="docs-prevnext"></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#usage">Usage</a><ul class="toc-headings"><li><a href="#parsing-objects">Parsing Objects</a></li><li><a href="#parsing-arrays">Parsing Arrays</a></li><li><a href="#stringifying">Stringifying</a></li><li><a href="#handling-of-null-values">Handling of <code>null</code> values</a></li><li><a href="#dealing-with-special-character-sets">Dealing with special character sets</a></li><li><a href="#rfc-3986-and-rfc-1738-space-encoding">RFC 3986 and RFC 1738 space encoding</a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/underbase/" class="nav-home"><img src="/underbase/img/logo.svg" alt="Underbase" width="66" height="58"/></a><div><h5>Docs</h5><a href="/underbase/docs/en/doc1.html">Getting Started (or other categories)</a><a href="/underbase/docs/en/doc2.html">Guides (or other categories)</a><a href="/underbase/docs/en/doc3.html">API Reference (or other categories)</a></div><div><h5>Community</h5><a href="https://stackoverflow.com/questions/tagged/" target="_blank" rel="noreferrer noopener">Stack Overflow</a><a href="https://discordapp.com/">Project Chat</a><a href="https://twitter.com/" target="_blank" rel="noreferrer noopener">Twitter</a></div><div><h5>More</h5><a href="/underbase/blog">Blog</a><a href="https://github.com/">GitHub</a><a class="github-button" data-icon="octicon-star" data-count-href="/facebook/docusaurus/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div></section></footer></div></body></html>