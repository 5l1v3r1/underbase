<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>node_modules/regexp-tree/README · Underbase</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="&lt;h1&gt;&lt;a class=&quot;anchor&quot; aria-hidden=&quot;true&quot; id=&quot;regexp-tree&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#regexp-tree&quot; aria-hidden=&quot;true&quot; class=&quot;hash-link&quot;&gt;&lt;svg class=&quot;hash-link-icon&quot; aria-hidden=&quot;true&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;regexp-tree&lt;/h1&gt;
"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="node_modules/regexp-tree/README · Underbase"/><meta property="og:type" content="website"/><meta property="og:url" content="https://sundowndev.github.io/underbase/"/><meta property="og:description" content="&lt;h1&gt;&lt;a class=&quot;anchor&quot; aria-hidden=&quot;true&quot; id=&quot;regexp-tree&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#regexp-tree&quot; aria-hidden=&quot;true&quot; class=&quot;hash-link&quot;&gt;&lt;svg class=&quot;hash-link-icon&quot; aria-hidden=&quot;true&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;regexp-tree&lt;/h1&gt;
"/><meta property="og:image" content="https://sundowndev.github.io/underbase/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://sundowndev.github.io/underbase/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/underbase/img/logo.svg"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="alternate" type="application/atom+xml" href="https://sundowndev.github.io/underbase/blog/atom.xml" title="Underbase Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://sundowndev.github.io/underbase/blog/feed.xml" title="Underbase Blog RSS Feed"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="/underbase/js/scrollSpy.js"></script><link rel="stylesheet" href="/underbase/css/main.css"/><script src="/underbase/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/underbase/"><img class="logo" src="/underbase/img/logo.svg" alt="Underbase"/><h2 class="headerTitleWithLogo">Underbase</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/underbase/docs/installation" target="_self">Guides</a></li><li class=""><a href="/underbase/docs/api" target="_self">API</a></li><li class=""><a href="/underbase/blog/" target="_self">Release notes</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle">node_modules/regexp-tree/README</h1></header><article><div><span><h1><a class="anchor" aria-hidden="true" id="regexp-tree"></a><a href="#regexp-tree" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>regexp-tree</h1>
<p><a href="https://travis-ci.org/DmitrySoshnikov/regexp-tree"><img src="https://travis-ci.org/DmitrySoshnikov/regexp-tree.svg?branch=master" alt="Build Status"></a> <a href="https://badge.fury.io/js/regexp-tree"><img src="https://badge.fury.io/js/regexp-tree.svg" alt="npm version"></a> <a href="https://www.npmjs.com/package/regexp-tree"><img src="https://img.shields.io/npm/dt/regexp-tree.svg" alt="npm downloads"></a></p>
<p>Regular expressions processor in JavaScript</p>
<p>TL;DR: <strong>RegExp Tree</strong> is a <em>regular expressions processor</em>, which includes <em>parser</em>, <em>traversal</em>, <em>transformer</em>, <em>optimizer</em>, and <em>interpreter</em> APIs.</p>
<p>You can get an overview of the tool in <a href="https://medium.com/@DmitrySoshnikov/regexp-tree-a-regular-expressions-parser-with-a-simple-ast-format-bcd4d5580df6">this article</a>.</p>
<h3><a class="anchor" aria-hidden="true" id="table-of-contents"></a><a href="#table-of-contents" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Table of Contents</h3>
<ul>
<li><a href="#installation">Installation</a></li>
<li><a href="#development">Development</a></li>
<li><a href="#usage-as-a-cli">Usage as a CLI</a></li>
<li><a href="#usage-from-node">Usage from Node</a></li>
<li><a href="#capturing-locations">Capturing locations</a></li>
<li><a href="#using-traversal-api">Using traversal API</a></li>
<li><a href="#using-transform-api">Using transform API</a>
<ul>
<li><a href="#transform-plugins">Transform plugins</a></li>
</ul></li>
<li><a href="#using-generator-api">Using generator API</a></li>
<li><a href="#using-optimizer-api">Using optimizer API</a>
<ul>
<li><a href="#optimizer-eslint-plugin">Optimizer ESLint plugin</a></li>
</ul></li>
<li><a href="#using-compat-transpiler-api">Using compat-transpiler API</a>
<ul>
<li><a href="#compat-transpiler-babel-plugin">Compat-transpiler Babel plugin</a></li>
</ul></li>
<li><a href="#regexp-extensions">RegExp extensions</a>
<ul>
<li><a href="#regexp-extensions-babel-plugin">RegExp extensions Babel plugin</a></li>
</ul></li>
<li><a href="#creating-regexp-objects">Creating RegExp objects</a></li>
<li><a href="#executing-regexes">Executing regexes</a></li>
<li><a href="#using-interpreter-api">Using interpreter API</a>
<ul>
<li><a href="#printing-nfadfa-tables">Printing NFA/DFA tables</a></li>
</ul></li>
<li><a href="#ast-nodes-specification">AST nodes specification</a></li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="installation"></a><a href="#installation" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Installation</h3>
<p>The parser can be installed as an <a href="https://www.npmjs.com/package/regexp-tree">npm module</a>:</p>
<pre><code class="hljs">npm <span class="hljs-keyword">install</span> -g regexp-tree
</code></pre>
<p>You can also <a href="https://astexplorer.net/#/gist/4ea2b52f0e546af6fb14f9b2f5671c1c/39b55944da3e5782396ffa1fea3ba68d126cd394">try it online</a> using <em>AST Explorer</em>.</p>
<h3><a class="anchor" aria-hidden="true" id="development"></a><a href="#development" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Development</h3>
<ol>
<li>Fork <a href="https://github.com/DmitrySoshnikov/regexp-tree">https://github.com/DmitrySoshnikov/regexp-tree</a> repo</li>
<li>If there is an actual issue from the <a href="https://github.com/DmitrySoshnikov/regexp-tree/issues">issues</a> list you'd like to work on, feel free to assign it yourself, or comment on it to avoid collisions (open a new issue if needed)</li>
<li>Make your changes</li>
<li>Make sure <code>npm test</code> still passes (add new tests if needed)</li>
<li>Submit a PR</li>
</ol>
<p>The <em>regexp-tree</em> parser is implemented as an automatic LR parser using <a href="https://www.npmjs.com/package/syntax-cli">Syntax</a> tool. The parser module is generated from the <a href="https://github.com/DmitrySoshnikov/regexp-tree/blob/master/src/parser/regexp.bnf">regexp grammar</a>, which is based on the regular expressions grammar used in ECMAScript.</p>
<p>For development from the github repository, run <code>build</code> command to generate the parser module, and transpile JS code:</p>
<pre><code class="hljs"><span class="hljs-attr">git</span> <span class="hljs-string">clone https://github.com/&lt;your-github-account&gt;/regexp-tree.git</span>
<span class="hljs-attr">cd</span> <span class="hljs-string">regexp-tree</span>
<span class="hljs-attr">npm</span> <span class="hljs-string">install</span>
<span class="hljs-attr">npm</span> <span class="hljs-string">run build</span>
</code></pre>
<blockquote>
<p>NOTE: JS code transpilation is used to support older versions of Node. For faster development cycle you can use <code>npm run watch</code> command, which continuously transpiles JS code.</p>
</blockquote>
<h3><a class="anchor" aria-hidden="true" id="usage-as-a-cli"></a><a href="#usage-as-a-cli" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Usage as a CLI</h3>
<p><strong>Note:</strong> the CLI is exposed as its own <a href="https://www.npmjs.com/package/regexp-tree-cli">regexp-tree-cli</a> module.</p>
<p>Check the options available from CLI:</p>
<pre><code class="hljs">regexp-<span class="hljs-built_in">tree</span>-cli --<span class="hljs-built_in">help</span>
</code></pre>
<pre><code class="hljs"><span class="hljs-attribute">Usage</span>: regexp-tree-cli [options]

<span class="vim">Option<span class="hljs-variable">s:</span>
   -<span class="hljs-keyword">e</span>, --expression   A regular expression <span class="hljs-keyword">to</span> <span class="hljs-keyword">be</span> parsed
   -<span class="hljs-keyword">l</span>, --<span class="hljs-keyword">loc</span>          Whether <span class="hljs-keyword">to</span> capture AST node locations
   -<span class="hljs-keyword">o</span>, --optimize     Applies optimizer <span class="hljs-keyword">on</span> the passed expression
   -<span class="hljs-keyword">c</span>, --compat       Applies compat-transpiler <span class="hljs-keyword">on</span> the passed expression
   -t, --table        <span class="hljs-keyword">Print</span> NFA/DFA transition tables (nfa/dfa/<span class="hljs-keyword">all</span>)
</span></code></pre>
<p>To parse a regular expression, pass <code>-e</code> option:</p>
<pre><code class="hljs">regexp-tree-cli -e <span class="hljs-comment">'/a|b/i'</span>
</code></pre>
<p>Which produces an AST node corresponding to this regular expression:</p>
<pre><code class="hljs css language-js">{
  <span class="hljs-attr">type</span>: <span class="hljs-string">'RegExp'</span>,
  <span class="hljs-attr">body</span>: {
    <span class="hljs-attr">type</span>: <span class="hljs-string">'Disjunction'</span>,
    <span class="hljs-attr">left</span>: {
      <span class="hljs-attr">type</span>: <span class="hljs-string">'Char'</span>,
      <span class="hljs-attr">value</span>: <span class="hljs-string">'a'</span>,
      <span class="hljs-attr">symbol</span>: <span class="hljs-string">'a'</span>,
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'simple'</span>,
      <span class="hljs-attr">codePoint</span>: <span class="hljs-number">97</span>
    },
    <span class="hljs-attr">right</span>: {
      <span class="hljs-attr">type</span>: <span class="hljs-string">'Char'</span>,
      <span class="hljs-attr">value</span>: <span class="hljs-string">'b'</span>,
      <span class="hljs-attr">symbol</span>: <span class="hljs-string">'b'</span>,
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'simple'</span>,
      <span class="hljs-attr">codePoint</span>: <span class="hljs-number">98</span>
    }
  },
  <span class="hljs-attr">flags</span>: <span class="hljs-string">'i'</span>,
}
</code></pre>
<blockquote>
<p>NOTE: the format of a regexp is <code>/ Body / OptionalFlags</code>.</p>
</blockquote>
<h3><a class="anchor" aria-hidden="true" id="usage-from-node"></a><a href="#usage-from-node" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Usage from Node</h3>
<p>The parser can also be used as a Node module:</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">const</span> regexpTree = <span class="hljs-built_in">require</span>(<span class="hljs-string">'regexp-tree'</span>);

<span class="hljs-built_in">console</span>.log(regexpTree.parse(<span class="hljs-regexp">/a|b/i</span>)); <span class="hljs-comment">// RegExp AST</span>
</code></pre>
<p>Note, <em>regexp-tree</em> supports parsing regexes from strings, and also from actual <code>RegExp</code> objects (in general -- from any object which can be coerced to a string). If some feature is not implemented yet in an actual JavaScript RegExp, it should be passed as a string:</p>
<pre><code class="hljs css language-js"><span class="hljs-comment">// Pass an actual JS RegExp object.</span>
regexpTree.parse(<span class="hljs-regexp">/a|b/i</span>);

<span class="hljs-comment">// Pass a string, since `s` flag may not be supported in older versions.</span>
regexpTree.parse(<span class="hljs-string">'/./s'</span>);
</code></pre>
<p>Also note, that in string-mode, escaping is done using two slashes <code>\\</code> per JavaScript:</p>
<pre><code class="hljs css language-js"><span class="hljs-comment">// As an actual regexp.</span>
regexpTree.parse(<span class="hljs-regexp">/\n/</span>);

<span class="hljs-comment">// As a string.</span>
regexpTree.parse(<span class="hljs-string">'/\\n/'</span>);
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="capturing-locations"></a><a href="#capturing-locations" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Capturing locations</h3>
<p>For source code transformation tools it might be useful also to capture <em>locations</em> of the AST nodes. From the command line it's controlled via the <code>-l</code> option:</p>
<pre><code class="hljs">regexp-<span class="hljs-keyword">tree</span>-cli -e <span class="hljs-string">'/ab/'</span> -l
</code></pre>
<p>This attaches <code>loc</code> object to each AST node:</p>
<pre><code class="hljs css language-js">{
  <span class="hljs-attr">type</span>: <span class="hljs-string">'RegExp'</span>,
  <span class="hljs-attr">body</span>: {
    <span class="hljs-attr">type</span>: <span class="hljs-string">'Alternative'</span>,
    <span class="hljs-attr">expressions</span>: [
      {
        <span class="hljs-attr">type</span>: <span class="hljs-string">'Char'</span>,
        <span class="hljs-attr">value</span>: <span class="hljs-string">'a'</span>,
        <span class="hljs-attr">symbol</span>: <span class="hljs-string">'a'</span>,
        <span class="hljs-attr">kind</span>: <span class="hljs-string">'simple'</span>,
        <span class="hljs-attr">codePoint</span>: <span class="hljs-number">97</span>,
        <span class="hljs-attr">loc</span>: {
          <span class="hljs-attr">start</span>: {
            <span class="hljs-attr">line</span>: <span class="hljs-number">1</span>,
            <span class="hljs-attr">column</span>: <span class="hljs-number">1</span>,
            <span class="hljs-attr">offset</span>: <span class="hljs-number">1</span>,
          },
          <span class="hljs-attr">end</span>: {
            <span class="hljs-attr">line</span>: <span class="hljs-number">1</span>,
            <span class="hljs-attr">column</span>: <span class="hljs-number">2</span>,
            <span class="hljs-attr">offset</span>: <span class="hljs-number">2</span>,
          },
        }
      },
      {
        <span class="hljs-attr">type</span>: <span class="hljs-string">'Char'</span>,
        <span class="hljs-attr">value</span>: <span class="hljs-string">'b'</span>,
        <span class="hljs-attr">symbol</span>: <span class="hljs-string">'b'</span>,
        <span class="hljs-attr">kind</span>: <span class="hljs-string">'simple'</span>,
        <span class="hljs-attr">codePoint</span>: <span class="hljs-number">98</span>,
        <span class="hljs-attr">loc</span>: {
          <span class="hljs-attr">start</span>: {
            <span class="hljs-attr">line</span>: <span class="hljs-number">1</span>,
            <span class="hljs-attr">column</span>: <span class="hljs-number">2</span>,
            <span class="hljs-attr">offset</span>: <span class="hljs-number">2</span>,
          },
          <span class="hljs-attr">end</span>: {
            <span class="hljs-attr">line</span>: <span class="hljs-number">1</span>,
            <span class="hljs-attr">column</span>: <span class="hljs-number">3</span>,
            <span class="hljs-attr">offset</span>: <span class="hljs-number">3</span>,
          },
        }
      }
    ],
    <span class="hljs-attr">loc</span>: {
      <span class="hljs-attr">start</span>: {
        <span class="hljs-attr">line</span>: <span class="hljs-number">1</span>,
        <span class="hljs-attr">column</span>: <span class="hljs-number">1</span>,
        <span class="hljs-attr">offset</span>: <span class="hljs-number">1</span>,
      },
      <span class="hljs-attr">end</span>: {
        <span class="hljs-attr">line</span>: <span class="hljs-number">1</span>,
        <span class="hljs-attr">column</span>: <span class="hljs-number">3</span>,
        <span class="hljs-attr">offset</span>: <span class="hljs-number">3</span>,
      },
    }
  },
  <span class="hljs-attr">flags</span>: <span class="hljs-string">''</span>,
  <span class="hljs-attr">loc</span>: {
    <span class="hljs-attr">start</span>: {
      <span class="hljs-attr">line</span>: <span class="hljs-number">1</span>,
      <span class="hljs-attr">column</span>: <span class="hljs-number">0</span>,
      <span class="hljs-attr">offset</span>: <span class="hljs-number">0</span>,
    },
    <span class="hljs-attr">end</span>: {
      <span class="hljs-attr">line</span>: <span class="hljs-number">1</span>,
      <span class="hljs-attr">column</span>: <span class="hljs-number">4</span>,
      <span class="hljs-attr">offset</span>: <span class="hljs-number">4</span>,
    },
  }
}
</code></pre>
<p>From Node it's controlled via <code>setOptions</code> method exposed on the parser:</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">const</span> regexpTree = <span class="hljs-built_in">require</span>(<span class="hljs-string">'regexp-tree'</span>);

<span class="hljs-keyword">const</span> parsed = regexpTree
  .parser
  .setOptions({<span class="hljs-attr">captureLocations</span>: <span class="hljs-literal">true</span>})
  .parse(<span class="hljs-regexp">/a|b/</span>);
</code></pre>
<p>The <code>setOptions</code> method sets global options, which are preserved between calls. It is also possible to provide options per a single <code>parse</code> call, which might be more preferred:</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">const</span> regexpTree = <span class="hljs-built_in">require</span>(<span class="hljs-string">'regexp-tree'</span>);

<span class="hljs-keyword">const</span> parsed = regexpTree.parse(<span class="hljs-regexp">/a|b/</span>, {
  <span class="hljs-attr">captureLocations</span>: <span class="hljs-literal">true</span>,
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="using-traversal-api"></a><a href="#using-traversal-api" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Using traversal API</h3>
<p>The <a href="https://github.com/DmitrySoshnikov/regexp-tree/tree/master/src/traverse">traverse</a> module allows handling needed AST nodes using the <em>visitor</em> pattern. In Node the module is exposed as the <code>regexpTree.traverse</code> method. Handlers receive an instance of the <a href="https://github.com/DmitrySoshnikov/regexp-tree/blob/master/src/traverse/README.md#nodepath-class">NodePath</a> class, which encapsulates <code>node</code> itself, its <code>parent</code> node, <code>property</code>, and <code>index</code> (in case the node is part of a collection).</p>
<p>Visiting a node follows this algorithm:</p>
<ul>
<li>call <code>pre</code> handler.</li>
<li>recurse into node's children.</li>
<li>call <code>post</code> handler.</li>
</ul>
<p>For each node type of interest, you can provide either:</p>
<ul>
<li>a function (<code>pre</code>).</li>
<li>an object with members <code>pre</code> and <code>post</code>.</li>
</ul>
<p>You can also provide a <code>*</code> handler which will be executed on every node.</p>
<p>Example:</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">const</span> regexpTree = <span class="hljs-built_in">require</span>(<span class="hljs-string">'regexp-tree'</span>);

<span class="hljs-comment">// Get AST.</span>
<span class="hljs-keyword">const</span> ast = regexpTree.parse(<span class="hljs-string">'/[a-z]{1,}/'</span>);

<span class="hljs-comment">// Traverse AST nodes.</span>
regexpTree.traverse(ast, {

  <span class="hljs-comment">// Visit every node before any type-specific handlers.</span>
  <span class="hljs-string">'*'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">{node}</span>) </span>{
    ...
  },

  <span class="hljs-comment">// Handle "Quantifier" node type.</span>
  Quantifier({node}) {
    ...
  },

  <span class="hljs-comment">// Handle "Char" node type, before and after.</span>
  Char: {
    pre({node}) {
      ...
    },
    post({node}) {
      ...
    }
  }

});

<span class="hljs-comment">// Generate the regexp.</span>
<span class="hljs-keyword">const</span> re = regexpTree.generate(ast);

<span class="hljs-built_in">console</span>.log(re); <span class="hljs-comment">// '/[a-z]+/'</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="using-transform-api"></a><a href="#using-transform-api" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Using transform API</h3>
<blockquote>
<p>NOTE: you can play with transformation APIs, and write actual transforms for quick tests in AST Explorer. See <a href="http://astexplorer.net/#/gist/d293d22742b42cd1f7ee7b7e5dc6f697/39b0aabc42fb6fb106b9e368341d3300098f08c0">this example</a>.</p>
</blockquote>
<p>While traverse module provides basic traversal API, which can be used for any purposes of AST handling, <em>transform</em> module focuses mainly on <em>transformation</em> of regular expressions.</p>
<p>It accepts a regular expressions in different formats (string, an actual <code>RegExp</code> object, or an AST), applies a set of transformations, and retuns an instance of <a href="https://github.com/DmitrySoshnikov/regexp-tree/blob/master/src/transform/README.md#transformresult">TransformResult</a>. Handles receive as a parameter the same <a href="https://github.com/DmitrySoshnikov/regexp-tree/blob/master/src/traverse/README.md#nodepath-class">NodePath</a> object used in traverse.</p>
<p>Example:</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">const</span> regexpTree = <span class="hljs-built_in">require</span>(<span class="hljs-string">'regexp-tree'</span>);

<span class="hljs-comment">// Handle nodes.</span>
<span class="hljs-keyword">const</span> re = regexpTree.transform(<span class="hljs-string">'/[a-z]{1,}/i'</span>, {

  <span class="hljs-comment">/**
   * Handle "Quantifier" node type,
   * transforming `{1,}` quantifier to `+`.
   */</span>
  Quantifier(path) {
    <span class="hljs-keyword">const</span> {node} = path;

    <span class="hljs-comment">// {1,} -&gt; +</span>
    <span class="hljs-keyword">if</span> (
      node.kind === <span class="hljs-string">'Range'</span> &amp;&amp;
      node.from === <span class="hljs-number">1</span> &amp;&amp;
      !node.to
    ) {
      path.replace({
        <span class="hljs-attr">type</span>: <span class="hljs-string">'Quantifier'</span>,
        <span class="hljs-attr">kind</span>: <span class="hljs-string">'+'</span>,
        <span class="hljs-attr">greedy</span>: node.greedy,
      });
    }
  },
});

<span class="hljs-built_in">console</span>.log(re.toString()); <span class="hljs-comment">// '/[a-z]+/i'</span>
<span class="hljs-built_in">console</span>.log(re.toRegExp()); <span class="hljs-comment">// /[a-z]+/i</span>
<span class="hljs-built_in">console</span>.log(re.getAST()); <span class="hljs-comment">// AST for /[a-z]+/i</span>
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="transform-plugins"></a><a href="#transform-plugins" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Transform plugins</h4>
<p>A <em>transformation plugin</em> is a module which exports a <em>transformation handler</em>. We have seen <a href="#using-transform-api">above</a> how we can pass a handler object directly to the <code>regexpTree.transform</code> method, here we extract it into a separate module, so it can be implemented and shared independently:</p>
<p>Example of a plugin:</p>
<pre><code class="hljs css language-js"><span class="hljs-comment">// file: ./regexp-tree-a-to-b-transform.js</span>


<span class="hljs-comment">/**
 * This plugin replaces chars 'a' with chars 'b'.
 */</span>
<span class="hljs-built_in">module</span>.exports = {
  Char({node}) {
    <span class="hljs-keyword">if</span> (node.kind === <span class="hljs-string">'simple'</span> &amp;&amp; node.value === <span class="hljs-string">'a'</span>) {
      node.value = <span class="hljs-string">'b'</span>;
      node.symbol = <span class="hljs-string">'b'</span>;
      node.codePoint = <span class="hljs-number">98</span>;
    }
  },
};
</code></pre>
<p>Once we have this plugin ready, we can require it, and pass to the <code>transform</code> function:</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">const</span> regexpTree = <span class="hljs-built_in">require</span>(<span class="hljs-string">'regexp-tree'</span>);
<span class="hljs-keyword">const</span> plugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./regexp-tree-a-to-b-transform'</span>);

<span class="hljs-keyword">const</span> re = regexpTree.transform(<span class="hljs-regexp">/(a|c)a+[a-z]/</span>, plugin);

<span class="hljs-built_in">console</span>.log(re.toRegExp()); <span class="hljs-comment">// /(b|c)b+[b-z]/</span>
</code></pre>
<blockquote>
<p>NOTE: we can also pass a <em>list of plugins</em> to the <code>regexpTree.transform</code>. In this case the plugins are applied in one pass in order. Another approach is to run several sequential calls to <code>transform</code>, setting up a pipeline, when a transformed AST is passed further to another plugin, etc.</p>
</blockquote>
<p>You can see other examples of transform plugins in the <a href="https://github.com/DmitrySoshnikov/regexp-tree/tree/master/src/optimizer/transforms">optimizer/transforms</a> or in the <a href="https://github.com/DmitrySoshnikov/regexp-tree/tree/master/src/compat-transpiler/transforms">compat-transpiler/transforms</a> directories.</p>
<h3><a class="anchor" aria-hidden="true" id="using-generator-api"></a><a href="#using-generator-api" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Using generator API</h3>
<p>The <a href="https://github.com/DmitrySoshnikov/regexp-tree/tree/master/src/generator">generator</a> module generates regular expressions from corresponding AST nodes. In Node the module is exposed as <code>regexpTree.generate</code> method.</p>
<p>Example:</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">const</span> regexpTree = <span class="hljs-built_in">require</span>(<span class="hljs-string">'regexp-tree'</span>);

<span class="hljs-keyword">const</span> re = regexpTree.generate({
  <span class="hljs-attr">type</span>: <span class="hljs-string">'RegExp'</span>,
  <span class="hljs-attr">body</span>: {
    <span class="hljs-attr">type</span>: <span class="hljs-string">'Char'</span>,
    <span class="hljs-attr">value</span>: <span class="hljs-string">'a'</span>,
    <span class="hljs-attr">symbol</span>: <span class="hljs-string">'a'</span>,
    <span class="hljs-attr">kind</span>: <span class="hljs-string">'simple'</span>,
    <span class="hljs-attr">codePoint</span>: <span class="hljs-number">97</span>
  },
  <span class="hljs-attr">flags</span>: <span class="hljs-string">'i'</span>,
});

<span class="hljs-built_in">console</span>.log(re); <span class="hljs-comment">// '/a/i'</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="using-optimizer-api"></a><a href="#using-optimizer-api" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Using optimizer API</h3>
<p><a href="https://github.com/DmitrySoshnikov/regexp-tree/tree/master/src/optimizer">Optimizer</a> transforms your regexp into an <em>optimized</em> version, replacing some sub-expressions with their idiomatic patterns. This might be good for different kinds of minifiers, as well as for regexp machines.</p>
<blockquote>
<p>NOTE: the Optimizer is implemented as a set of <em>regexp-tree</em> <a href="#transform-plugins">plugins</a>.</p>
</blockquote>
<p>Example:</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">const</span> regexpTree = <span class="hljs-built_in">require</span>(<span class="hljs-string">'regexp-tree'</span>);

<span class="hljs-keyword">const</span> originalRe = <span class="hljs-regexp">/[a-zA-Z_0-9][A-Z_\da-z]*\e{1,}/</span>;

<span class="hljs-keyword">const</span> optimizedRe = regexpTree
  .optimize(originalRe)
  .toRegExp();

<span class="hljs-built_in">console</span>.log(optimizedRe); <span class="hljs-comment">// /\w+e+/</span>
</code></pre>
<p>From CLI the optimizer is available via <code>--optimize</code> (<code>-o</code>) option:</p>
<pre><code class="hljs">regexp-tree-cli -e '/[<span class="hljs-string">a-zA-Z_0-9</span>][<span class="hljs-symbol">A-Z_\da-z</span>]*\e{1,}/' -o
</code></pre>
<p>Result:</p>
<pre><code class="hljs"><span class="hljs-string">Optimized:</span> <span class="hljs-regexp">/\w+e+/</span>
</code></pre>
<p>See the <a href="https://github.com/DmitrySoshnikov/regexp-tree/tree/master/src/optimizer">optimizer README</a> for more details.</p>
<h4><a class="anchor" aria-hidden="true" id="optimizer-eslint-plugin"></a><a href="#optimizer-eslint-plugin" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Optimizer ESLint plugin</h4>
<p>The <a href="https://github.com/DmitrySoshnikov/regexp-tree/tree/master/src/optimizer">optimizer</a> module is also available as an <em>ESLint plugin</em>, which can be installed at: <a href="https://www.npmjs.com/package/eslint-plugin-optimize-regex">eslint-plugin-optimize-regex</a>.</p>
<h3><a class="anchor" aria-hidden="true" id="using-compat-transpiler-api"></a><a href="#using-compat-transpiler-api" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Using compat-transpiler API</h3>
<p>The <a href="https://github.com/DmitrySoshnikov/regexp-tree/tree/master/src/compat-transpiler">compat-transpiler</a> module translates your regexp in new format or in new syntax, into an equivalent regexp in a legacy representation, so it can be used in engines which don't yet implement the new syntax.</p>
<blockquote>
<p>NOTE: the compat-transpiler is implemented as a set of <em>regexp-tree</em> <a href="#transform-plugins">plugins</a>.</p>
</blockquote>
<p>Example, &quot;dotAll&quot; <code>s</code> flag:</p>
<pre><code class="hljs css language-js">/./s
</code></pre>
<p>Is translated into:</p>
<pre><code class="hljs css language-js">/[\<span class="hljs-number">0</span>-\uFFFF]/
</code></pre>
<p>Or <a href="#named-capturing-group">named capturing groups</a>:</p>
<pre><code class="hljs css language-js">/(?&lt;value&gt;a)\k&lt;value&gt;\1/
</code></pre>
<p>Becomes:</p>
<pre><code class="hljs css language-js">/(a)\<span class="hljs-number">1</span>\<span class="hljs-number">1</span>/
</code></pre>
<p>To use the API from Node:</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">const</span> regexpTree = <span class="hljs-built_in">require</span>(<span class="hljs-string">'regexp-tree'</span>);

<span class="hljs-comment">// Using new syntax.</span>
<span class="hljs-keyword">const</span> originalRe = <span class="hljs-string">'/(?&lt;all&gt;.)\\k&lt;all&gt;/s'</span>;

<span class="hljs-comment">// For legacy engines.</span>
<span class="hljs-keyword">const</span> compatTranspiledRe = regexpTree
  .compatTranspile(originalRe)
  .toRegExp();

<span class="hljs-built_in">console</span>.log(compatTranspiledRe); <span class="hljs-comment">// /([\0-\uFFFF])\1/</span>
</code></pre>
<p>From CLI the compat-transpiler is available via <code>--compat</code> (<code>-c</code>) option:</p>
<pre><code class="hljs">regexp-tree-cli -e <span class="hljs-comment">'/(?<span class="hljs-doctag">&lt;all&gt;</span>.)\k<span class="hljs-doctag">&lt;all&gt;</span>/s' -c</span>
</code></pre>
<p>Result:</p>
<pre><code class="hljs">Compat: /([<span class="hljs-symbol">\0</span>-<span class="hljs-symbol">\u</span>FFFF])<span class="hljs-symbol">\1</span>/
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="compat-transpiler-babel-plugin"></a><a href="#compat-transpiler-babel-plugin" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Compat-transpiler Babel plugin</h4>
<p>The <a href="https://github.com/DmitrySoshnikov/regexp-tree/tree/master/src/compat-transpiler">compat-transpiler</a> module is also available as a <em>Babel plugin</em>, which can be installed at: <a href="https://www.npmjs.com/package/babel-plugin-transform-modern-regexp">babel-plugin-transform-modern-regexp</a>.</p>
<p>Note, the plugin also includes <a href="#regexp-extensions">extended regexp</a> features.</p>
<h3><a class="anchor" aria-hidden="true" id="regexp-extensions"></a><a href="#regexp-extensions" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>RegExp extensions</h3>
<p>Besides future proposals, like <a href="#named-capturing-group">named capturing group</a>, and other which are being currently standardized, <em>regexp-tree</em> also supports <em>non-standard</em> features.</p>
<blockquote>
<p>NOTE: <em>&quot;non-standard&quot;</em> means specifically ECMAScript standard, since in other regexp egnines, e.g. PCRE, Python, etc. these features are standard.</p>
</blockquote>
<p>One of such featurs is <code>x</code> flag, which enables <em>extended</em> mode of regular expressions. In this mode most of whitespaces are ignored, and expressions can use #-comments.</p>
<p>Example:</p>
<pre><code class="hljs css language-regex">/
  # A regular expression <span class="hljs-keyword">for</span> <span class="hljs-built_in">date</span>.

  (?&lt;<span class="hljs-built_in">year</span>&gt;\d{<span class="hljs-number">4</span>})-    # <span class="hljs-built_in">year</span> part of a <span class="hljs-built_in">date</span>
  (?&lt;<span class="hljs-built_in">month</span>&gt;\d{<span class="hljs-number">2</span>})-   # <span class="hljs-built_in">month</span> part of a <span class="hljs-built_in">date</span>
  (?&lt;<span class="hljs-built_in">day</span>&gt;\d{<span class="hljs-number">2</span>})      # <span class="hljs-built_in">day</span> part of a <span class="hljs-built_in">date</span>

/x
</code></pre>
<p>This is normally parsed by the <em>regexp-tree</em> parser, and <a href="#using-compat-transpiler-api">compat-transpiler</a> has full support for it; it's translated into:</p>
<pre><code class="hljs css language-regex">/(<span class="hljs-tag">\<span class="hljs-name">d</span><span class="hljs-string">{4}</span></span>)-(<span class="hljs-tag">\<span class="hljs-name">d</span><span class="hljs-string">{2}</span></span>)-(<span class="hljs-tag">\<span class="hljs-name">d</span><span class="hljs-string">{2}</span></span>)/
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="regexp-extensions-babel-plugin"></a><a href="#regexp-extensions-babel-plugin" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>RegExp extensions Babel plugin</h4>
<p>The regexp extensions are also available as a <em>Babel plugin</em>, which can be installed at: <a href="https://www.npmjs.com/package/babel-plugin-transform-modern-regexp">babel-plugin-transform-modern-regexp</a>.</p>
<p>Note, the plugin also includes <a href="#using-compat-transpiler-api">compat-transpiler</a> features.</p>
<h3><a class="anchor" aria-hidden="true" id="creating-regexp-objects"></a><a href="#creating-regexp-objects" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Creating RegExp objects</h3>
<p>To create an actual <code>RegExp</code> JavaScript object, we can use <code>regexpTree.toRegExp</code> method:</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">const</span> regexpTree = <span class="hljs-built_in">require</span>(<span class="hljs-string">'regexp-tree'</span>);

<span class="hljs-keyword">const</span> re = regexpTree.toRegExp(<span class="hljs-string">'/[a-z]/i'</span>);

<span class="hljs-built_in">console</span>.log(
  re.test(<span class="hljs-string">'a'</span>), <span class="hljs-comment">// true</span>
  re.test(<span class="hljs-string">'Z'</span>), <span class="hljs-comment">// true</span>
);
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="executing-regexes"></a><a href="#executing-regexes" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Executing regexes</h3>
<p>It is also possible to execute regular expressions using <code>exec</code> API method, which has support for new syntax, and features, such as <a href="#named-capturing-group">named capturing group</a>, etc:</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">const</span> regexpTree = <span class="hljs-built_in">require</span>(<span class="hljs-string">'regexp-tree'</span>);

<span class="hljs-keyword">const</span> re = <span class="hljs-string">`/

  # A regular expression for date.

  (?&lt;year&gt;\\d{4})-    # year part of a date
  (?&lt;month&gt;\\d{2})-   # month part of a date
  (?&lt;day&gt;\\d{2})      # day part of a date

/x`</span>;

<span class="hljs-keyword">const</span> string = <span class="hljs-string">'2017-04-14'</span>;

<span class="hljs-keyword">const</span> result = regexpTree.exec(re, string);

<span class="hljs-built_in">console</span>.log(result.groups); <span class="hljs-comment">// {year: '2017', month: '04', day: '14'}</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="using-interpreter-api"></a><a href="#using-interpreter-api" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Using interpreter API</h3>
<blockquote>
<p>NOTE: you can read more about implementation details of the interpreter in <a href="https://medium.com/@DmitrySoshnikov/building-a-regexp-machine-part-1-regular-grammars-d4986b585d7e">this series of articles</a>.</p>
</blockquote>
<p>In addition to executing regular expressions using JavaScript built-in RegExp engine, RegExp Tree also implements own <a href="https://github.com/DmitrySoshnikov/regexp-tree/tree/master/src/interpreter/finite-automaton">interpreter</a> based on classic NFA/DFA finite automaton engine.</p>
<p>Currently it aims educational purposes -- to trace the regexp matching process, transitioning in NFA/DFA states. It also allows building state transitioning table, which can be used for custom implementation. In API the module is exposed as <code>fa</code> (finite-automaton) object.</p>
<p>Example:</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">const</span> {fa} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'regexp-tree'</span>);

<span class="hljs-keyword">const</span> re = <span class="hljs-regexp">/ab|c*/</span>;

<span class="hljs-built_in">console</span>.log(fa.test(re, <span class="hljs-string">'ab'</span>)); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(fa.test(re, <span class="hljs-string">''</span>)); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(fa.test(re, <span class="hljs-string">'c'</span>)); <span class="hljs-comment">// true</span>

<span class="hljs-comment">// NFA, and its transition table.</span>
<span class="hljs-keyword">const</span> nfa = fa.toNFA(re);
<span class="hljs-built_in">console</span>.log(nfa.getTransitionTable());

<span class="hljs-comment">// DFA, and its transition table.</span>
<span class="hljs-keyword">const</span> dfa = fa.toDFA(re);
<span class="hljs-built_in">console</span>.log(dfa.getTransitionTable());
</code></pre>
<p>For more granular work with NFA and DFA, <code>fa</code> module also exposes convenient builders, so you can build NFA fragments directly:</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">const</span> {fa} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'regexp-tree'</span>);

<span class="hljs-keyword">const</span> {
  alt,
  char,
  or,
  rep,
} = fa.builders;

<span class="hljs-comment">// ab|c*</span>
<span class="hljs-keyword">const</span> re = or(
  alt(char(<span class="hljs-string">'a'</span>), char(<span class="hljs-string">'b'</span>)),
  rep(char(<span class="hljs-string">'c'</span>))
);

<span class="hljs-built_in">console</span>.log(re.matches(<span class="hljs-string">'ab'</span>)); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(re.matches(<span class="hljs-string">''</span>)); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(re.matches(<span class="hljs-string">'c'</span>)); <span class="hljs-comment">// true</span>

<span class="hljs-comment">// Build DFA from NFA</span>
<span class="hljs-keyword">const</span> {DFA} = fa;

<span class="hljs-keyword">const</span> reDFA = <span class="hljs-keyword">new</span> DFA(re);

<span class="hljs-built_in">console</span>.log(reDFA.matches(<span class="hljs-string">'ab'</span>)); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(reDFA.matches(<span class="hljs-string">''</span>)); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(reDFA.matches(<span class="hljs-string">'c'</span>)); <span class="hljs-comment">// true</span>
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="printing-nfa-dfa-tables"></a><a href="#printing-nfa-dfa-tables" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Printing NFA/DFA tables</h4>
<p>The <code>--table</code> option allows displaying NFA/DFA transition tables. RegExp Tree also applies <em>DFA minimization</em> (using <em>N-equivalence</em> algorithm), and produces the minimal transition table as its final result.</p>
<p>In the example below for the <code>/a|b|c/</code> regexp, we first obtain the NFA transition table, which is further converted to the original DFA transition table (down from the 10 non-deterministic states to 4 deterministic states), and eventually minimized to the final DFA table (from 4 to only 2 states).</p>
<pre><code class="hljs">./bin/regexp-tree-cli -e <span class="hljs-string">'/a|b|c/'</span> --<span class="hljs-keyword">table</span> all
</code></pre>
<p>Result:</p>
<pre><code class="hljs">&gt; - starting
✓ - accepting

NFA transition table:

┌─────┬───┬───┬────┬─────────────┐
│     │ a │ b │ c  │ ε*          │
├─────┼───┼───┼────┼─────────────┤
│ <span class="hljs-number">1</span> &gt; │   │   │    │ {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>} │
├─────┼───┼───┼────┼─────────────┤
│ <span class="hljs-number">2</span>   │   │   │    │ {<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>}     │
├─────┼───┼───┼────┼─────────────┤
│ <span class="hljs-number">3</span>   │ <span class="hljs-number">4</span> │   │    │ <span class="hljs-number">3</span>           │
├─────┼───┼───┼────┼─────────────┤
│ <span class="hljs-number">4</span>   │   │   │    │ {<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>}     │
├─────┼───┼───┼────┼─────────────┤
│ <span class="hljs-number">5</span>   │   │   │    │ {<span class="hljs-number">5</span>,<span class="hljs-number">6</span>}       │
├─────┼───┼───┼────┼─────────────┤
│ <span class="hljs-number">6</span> ✓ │   │   │    │ <span class="hljs-number">6</span>           │
├─────┼───┼───┼────┼─────────────┤
│ <span class="hljs-number">7</span>   │   │ <span class="hljs-number">8</span> │    │ <span class="hljs-number">7</span>           │
├─────┼───┼───┼────┼─────────────┤
│ <span class="hljs-number">8</span>   │   │   │    │ {<span class="hljs-number">8</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>}     │
├─────┼───┼───┼────┼─────────────┤
│ <span class="hljs-number">9</span>   │   │   │ <span class="hljs-number">10</span> │ <span class="hljs-number">9</span>           │
├─────┼───┼───┼────┼─────────────┤
│ <span class="hljs-number">10</span>  │   │   │    │ {<span class="hljs-number">10</span>,<span class="hljs-number">6</span>}      │
└─────┴───┴───┴────┴─────────────┘


DFA: Original transition table:

┌─────┬───┬───┬───┐
│     │ a │ b │ c │
├─────┼───┼───┼───┤
│ <span class="hljs-number">1</span> &gt; │ <span class="hljs-number">4</span> │ <span class="hljs-number">3</span> │ <span class="hljs-number">2</span> │
├─────┼───┼───┼───┤
│ <span class="hljs-number">2</span> ✓ │   │   │   │
├─────┼───┼───┼───┤
│ <span class="hljs-number">3</span> ✓ │   │   │   │
├─────┼───┼───┼───┤
│ <span class="hljs-number">4</span> ✓ │   │   │   │
└─────┴───┴───┴───┘


DFA: Minimized transition table:

┌─────┬───┬───┬───┐
│     │ a │ b │ c │
├─────┼───┼───┼───┤
│ <span class="hljs-number">1</span> &gt; │ <span class="hljs-number">2</span> │ <span class="hljs-number">2</span> │ <span class="hljs-number">2</span> │
├─────┼───┼───┼───┤
│ <span class="hljs-number">2</span> ✓ │   │   │   │
└─────┴───┴───┴───┘
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="ast-nodes-specification"></a><a href="#ast-nodes-specification" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>AST nodes specification</h3>
<p>Below are the AST node types for different regular expressions patterns:</p>
<ul>
<li><a href="#char">Char</a>
<ul>
<li><a href="#simple-char">Simple char</a></li>
<li><a href="#escaped-char">Escaped char</a></li>
<li><a href="#meta-char">Meta char</a></li>
<li><a href="#control-char">Control char</a></li>
<li><a href="#hex-char-code">Hex char-code</a></li>
<li><a href="#decimal-char-code">Decimal char-code</a></li>
<li><a href="#octal-char-code">Octal char-code</a></li>
<li><a href="#unicode">Unicode</a></li>
</ul></li>
<li><a href="#character-class">Character class</a>
<ul>
<li><a href="#positive-character-class">Positive character class</a></li>
<li><a href="#negative-character-class">Negative character class</a></li>
<li><a href="#character-class-ranges">Character class ranges</a></li>
</ul></li>
<li><a href="#unicode-properties">Unicode properties</a></li>
<li><a href="#alternative">Alternative</a></li>
<li><a href="#disjunction">Disjunction</a></li>
<li><a href="#groups">Groups</a>
<ul>
<li><a href="#capturing-group">Capturing group</a></li>
<li><a href="#named-capturing-group">Named capturing group</a></li>
<li><a href="#non-capturing-group">Non-capturing group</a></li>
<li><a href="#backreferences">Backreferences</a></li>
</ul></li>
<li><a href="#quantifiers">Quantifiers</a>
<ul>
<li><a href="#-zero-or-one">? zero-or-one</a></li>
<li><a href="#-zero-or-more">* zero-or-more</a></li>
<li><a href="#-one-or-more">+ one-or-more</a></li>
<li><a href="#range-based-quantifiers">Range-based quantifiers</a>
<ul>
<li><a href="#exact-number-of-matches">Exact number of matches</a></li>
<li><a href="#open-range">Open range</a></li>
<li><a href="#closed-range">Closed range</a></li>
</ul></li>
<li><a href="#non-greedy">Non-greedy</a></li>
</ul></li>
<li><a href="#assertions">Assertions</a>
<ul>
<li><a href="#-begin-marker">^ begin marker</a></li>
<li><a href="#-end-marker">$ end marker</a></li>
<li><a href="#boundary-assertions">Boundary assertions</a></li>
<li><a href="#lookahead-assertions">Lookahead assertions</a>
<ul>
<li><a href="#positive-lookahead-assertion">Positive lookahead assertion</a></li>
<li><a href="#negative-lookahead-assertion">Negative lookahead assertion</a></li>
</ul></li>
<li><a href="#lookbehind-assertions">Lookbehind assertions</a>
<ul>
<li><a href="#positive-lookbehind-assertion">Positive lookbehind assertion</a></li>
<li><a href="#negative-lookbehind-assertion">Negative lookbehind assertion</a></li>
</ul></li>
</ul></li>
</ul>
<h4><a class="anchor" aria-hidden="true" id="char"></a><a href="#char" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Char</h4>
<p>A basic building block, single character. Can be <em>escaped</em>, and be of different <em>kinds</em>.</p>
<h5><a class="anchor" aria-hidden="true" id="simple-char"></a><a href="#simple-char" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Simple char</h5>
<p>Basic <em>non-escaped</em> char in a regexp:</p>
<pre><code class="hljs"><span class="hljs-attribute">z</span>
</code></pre>
<p>Node:</p>
<pre><code class="hljs css language-js">{
  <span class="hljs-attr">type</span>: <span class="hljs-string">'Char'</span>,
  <span class="hljs-attr">value</span>: <span class="hljs-string">'z'</span>,
  <span class="hljs-attr">symbol</span>: <span class="hljs-string">'z'</span>,
  <span class="hljs-attr">kind</span>: <span class="hljs-string">'simple'</span>,
  <span class="hljs-attr">codePoint</span>: <span class="hljs-number">122</span>
}
</code></pre>
<blockquote>
<p>NOTE: to test this from CLI, the char should be in an actual regexp -- <code>/z/</code>.</p>
</blockquote>
<h5><a class="anchor" aria-hidden="true" id="escaped-char"></a><a href="#escaped-char" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Escaped char</h5>
<pre><code class="hljs"><span class="hljs-string">\z</span>
</code></pre>
<p>The same value, <code>escaped</code> flag is added:</p>
<pre><code class="hljs css language-js">{
  <span class="hljs-attr">type</span>: <span class="hljs-string">'Char'</span>,
  <span class="hljs-attr">value</span>: <span class="hljs-string">'z'</span>,
  <span class="hljs-attr">symbol</span>: <span class="hljs-string">'z'</span>,
  <span class="hljs-attr">kind</span>: <span class="hljs-string">'simple'</span>,
  <span class="hljs-attr">codePoint</span>: <span class="hljs-number">122</span>,
  <span class="hljs-attr">escaped</span>: <span class="hljs-literal">true</span>
}
</code></pre>
<p>Escaping is mostly used with meta symbols:</p>
<pre><code class="hljs"><span class="hljs-comment">// Syntax error</span>
<span class="hljs-comment">*</span>
</code></pre>
<pre><code class="hljs"><span class="hljs-string">\*</span>
</code></pre>
<p>OK, node:</p>
<pre><code class="hljs css language-js">{
  <span class="hljs-attr">type</span>: <span class="hljs-string">'Char'</span>,
  <span class="hljs-attr">value</span>: <span class="hljs-string">'*'</span>,
  <span class="hljs-attr">symbol</span>: <span class="hljs-string">'*'</span>,
  <span class="hljs-attr">kind</span>: <span class="hljs-string">'simple'</span>,
  <span class="hljs-attr">codePoint</span>: <span class="hljs-number">42</span>,
  <span class="hljs-attr">escaped</span>: <span class="hljs-literal">true</span>
}
</code></pre>
<h5><a class="anchor" aria-hidden="true" id="meta-char"></a><a href="#meta-char" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Meta char</h5>
<p>A <em>meta character</em> should not be confused with an <a href="#escaped-char">escaped char</a>.</p>
<p>Example:</p>
<pre><code class="hljs"><span class="hljs-string">\n</span>
</code></pre>
<p>Node:</p>
<pre><code class="hljs css language-js">{
  <span class="hljs-attr">type</span>: <span class="hljs-string">'Char'</span>,
  <span class="hljs-attr">value</span>: <span class="hljs-string">'\\n'</span>,
  <span class="hljs-attr">symbol</span>: <span class="hljs-string">'\n'</span>,
  <span class="hljs-attr">kind</span>: <span class="hljs-string">'meta'</span>,
  <span class="hljs-attr">codePoint</span>: <span class="hljs-number">10</span>
}
</code></pre>
<p>Among other meta character are: <code>.</code>, <code>\f</code>, <code>\r</code>, <code>\n</code>, <code>\t</code>, <code>\v</code>, <code>\0</code>, <code>[\b]</code> (backspace char), <code>\s</code>, <code>\S</code>, <code>\w</code>, <code>\W</code>, <code>\d</code>, <code>\D</code>.</p>
<blockquote>
<p>NOTE: Meta characters representing ranges (like <code>.</code>, <code>\s</code>, etc.) have <code>undefined</code> value for <code>symbol</code> and <code>NaN</code> for <code>codePoint</code>.</p>
</blockquote>
<blockquote>
<p>NOTE: <code>\b</code> and <code>\B</code> are parsed as <code>Assertion</code> node type, not <code>Char</code>.</p>
</blockquote>
<h5><a class="anchor" aria-hidden="true" id="control-char"></a><a href="#control-char" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Control char</h5>
<p>A char preceded with <code>\c</code>, e.g. <code>\cx</code>, which stands for <code>CTRL+x</code>:</p>
<pre><code class="hljs"><span class="hljs-string">\cx</span>
</code></pre>
<p>Node:</p>
<pre><code class="hljs css language-js">{
  <span class="hljs-attr">type</span>: <span class="hljs-string">'Char'</span>,
  <span class="hljs-attr">value</span>: <span class="hljs-string">'\\cx'</span>,
  <span class="hljs-attr">symbol</span>: <span class="hljs-literal">undefined</span>,
  <span class="hljs-attr">kind</span>: <span class="hljs-string">'control'</span>,
  <span class="hljs-attr">codePoint</span>: <span class="hljs-literal">NaN</span>
}
</code></pre>
<h5><a class="anchor" aria-hidden="true" id="hex-char-code"></a><a href="#hex-char-code" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>HEX char-code</h5>
<p>A char preceded with <code>\x</code>, followed by a HEX-code, e.g. <code>\x3B</code> (symbol <code>;</code>):</p>
<pre><code class="hljs"><span class="hljs-string">\x3B</span>
</code></pre>
<p>Node:</p>
<pre><code class="hljs css language-js">{
  <span class="hljs-attr">type</span>: <span class="hljs-string">'Char'</span>,
  <span class="hljs-attr">value</span>: <span class="hljs-string">'\\x3B'</span>,
  <span class="hljs-attr">symbol</span>: <span class="hljs-string">';'</span>,
  <span class="hljs-attr">kind</span>: <span class="hljs-string">'hex'</span>,
  <span class="hljs-attr">codePoint</span>: <span class="hljs-number">59</span>
}
</code></pre>
<h5><a class="anchor" aria-hidden="true" id="decimal-char-code"></a><a href="#decimal-char-code" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Decimal char-code</h5>
<p>Char-code:</p>
<pre><code class="hljs">\<span class="hljs-number">42</span>
</code></pre>
<p>Node:</p>
<pre><code class="hljs css language-js">{
  <span class="hljs-attr">type</span>: <span class="hljs-string">'Char'</span>,
  <span class="hljs-attr">value</span>: <span class="hljs-string">'\\42'</span>,
  <span class="hljs-attr">symbol</span>: <span class="hljs-string">'*'</span>,
  <span class="hljs-attr">kind</span>: <span class="hljs-string">'decimal'</span>,
  <span class="hljs-attr">codePoint</span>: <span class="hljs-number">42</span>
}
</code></pre>
<h5><a class="anchor" aria-hidden="true" id="octal-char-code"></a><a href="#octal-char-code" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Octal char-code</h5>
<p>Char-code started with <code>\0</code>, followed by an octal number:</p>
<pre><code class="hljs">\<span class="hljs-number">073</span>
</code></pre>
<p>Node:</p>
<pre><code class="hljs css language-js">{
  <span class="hljs-attr">type</span>: <span class="hljs-string">'Char'</span>,
  <span class="hljs-attr">value</span>: <span class="hljs-string">'\\073'</span>,
  <span class="hljs-attr">symbol</span>: <span class="hljs-string">';'</span>,
  <span class="hljs-attr">kind</span>: <span class="hljs-string">'oct'</span>,
  <span class="hljs-attr">codePoint</span>: <span class="hljs-number">59</span>
}
</code></pre>
<h5><a class="anchor" aria-hidden="true" id="unicode"></a><a href="#unicode" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Unicode</h5>
<p>Unicode char started with <code>\u</code>, followed by a hex number:</p>
<pre><code class="hljs"><span class="hljs-string">\u003B</span>
</code></pre>
<p>Node:</p>
<pre><code class="hljs css language-js">{
  <span class="hljs-attr">type</span>: <span class="hljs-string">'Char'</span>,
  <span class="hljs-attr">value</span>: <span class="hljs-string">'\\u003B'</span>,
  <span class="hljs-attr">symbol</span>: <span class="hljs-string">';'</span>,
  <span class="hljs-attr">kind</span>: <span class="hljs-string">'unicode'</span>,
  <span class="hljs-attr">codePoint</span>: <span class="hljs-number">59</span>
}
</code></pre>
<p>When using the <code>u</code> flag, unicode chars can also be represented using <code>\u</code> followed by a hex number between curly braces:</p>
<pre><code class="hljs"><span class="hljs-tag">\<span class="hljs-name">u</span><span class="hljs-string">{1F680}</span></span>
</code></pre>
<p>Node:</p>
<pre><code class="hljs css language-js">{
  <span class="hljs-attr">type</span>: <span class="hljs-string">'Char'</span>,
  <span class="hljs-attr">value</span>: <span class="hljs-string">'\\u{1F680}'</span>,
  <span class="hljs-attr">symbol</span>: <span class="hljs-string">'🚀'</span>,
  <span class="hljs-attr">kind</span>: <span class="hljs-string">'unicode'</span>,
  <span class="hljs-attr">codePoint</span>: <span class="hljs-number">128640</span>
}
</code></pre>
<p>When using the <code>u</code> flag, unicode chars can also be represented using a surrogate pair:</p>
<pre><code class="hljs"><span class="hljs-symbol">\u</span>d83d<span class="hljs-symbol">\u</span>de80
</code></pre>
<p>Node:</p>
<pre><code class="hljs css language-js">{
  <span class="hljs-attr">type</span>: <span class="hljs-string">'Char'</span>,
  <span class="hljs-attr">value</span>: <span class="hljs-string">'\\ud83d\\ude80'</span>,
  <span class="hljs-attr">symbol</span>: <span class="hljs-string">'🚀'</span>,
  <span class="hljs-attr">kind</span>: <span class="hljs-string">'unicode'</span>,
  <span class="hljs-attr">codePoint</span>: <span class="hljs-number">128640</span>,
  <span class="hljs-attr">isSurrogatePair</span>: <span class="hljs-literal">true</span>
}
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="character-class"></a><a href="#character-class" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Character class</h4>
<p>Character classes define a <em>set</em> of characters. A set may include as simple characters, as well as <em>character ranges</em>. A class can be <em>positive</em> (any from the characters in the class match), or <em>negative</em> (any <em>but</em> the characters from the class match).</p>
<h5><a class="anchor" aria-hidden="true" id="positive-character-class"></a><a href="#positive-character-class" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Positive character class</h5>
<p>A positive character class is defined between <code>[</code> and <code>]</code> brackets:</p>
<pre><code class="hljs">[a*]
</code></pre>
<p>A node:</p>
<pre><code class="hljs css language-js">{
  <span class="hljs-attr">type</span>: <span class="hljs-string">'CharacterClass'</span>,
  <span class="hljs-attr">expressions</span>: [
    {
      <span class="hljs-attr">type</span>: <span class="hljs-string">'Char'</span>,
      <span class="hljs-attr">value</span>: <span class="hljs-string">'a'</span>,
      <span class="hljs-attr">symbol</span>: <span class="hljs-string">'a'</span>,
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'simple'</span>,
      <span class="hljs-attr">codePoint</span>: <span class="hljs-number">97</span>
    },
    {
      <span class="hljs-attr">type</span>: <span class="hljs-string">'Char'</span>,
      <span class="hljs-attr">value</span>: <span class="hljs-string">'*'</span>,
      <span class="hljs-attr">symbol</span>: <span class="hljs-string">'*'</span>,
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'simple'</span>,
      <span class="hljs-attr">codePoint</span>: <span class="hljs-number">42</span>
    }
  ]
}
</code></pre>
<blockquote>
<p>NOTE: some meta symbols are treated as normal characters in a character class. E.g. <code>*</code> is not a repetition quantifier, but a simple char.</p>
</blockquote>
<h5><a class="anchor" aria-hidden="true" id="negative-character-class"></a><a href="#negative-character-class" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Negative character class</h5>
<p>A negative character class is defined between <code>[^</code> and <code>]</code> brackets:</p>
<pre><code class="hljs">[<span class="hljs-comment">^ab</span>]
</code></pre>
<p>An AST node is the same, just <code>negative</code> property is added:</p>
<pre><code class="hljs css language-js">{
  <span class="hljs-attr">type</span>: <span class="hljs-string">'CharacterClass'</span>,
  <span class="hljs-attr">negative</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">expressions</span>: [
    {
      <span class="hljs-attr">type</span>: <span class="hljs-string">'Char'</span>,
      <span class="hljs-attr">value</span>: <span class="hljs-string">'a'</span>,
      <span class="hljs-attr">symbol</span>: <span class="hljs-string">'a'</span>,
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'simple'</span>,
      <span class="hljs-attr">codePoint</span>: <span class="hljs-number">97</span>
    },
    {
      <span class="hljs-attr">type</span>: <span class="hljs-string">'Char'</span>,
      <span class="hljs-attr">value</span>: <span class="hljs-string">'b'</span>,
      <span class="hljs-attr">symbol</span>: <span class="hljs-string">'b'</span>,
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'simple'</span>,
      <span class="hljs-attr">codePoint</span>: <span class="hljs-number">98</span>
    }
  ]
}
</code></pre>
<h5><a class="anchor" aria-hidden="true" id="character-class-ranges"></a><a href="#character-class-ranges" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Character class ranges</h5>
<p>As mentioned, a character class may also contain <em>ranges</em> of symbols:</p>
<pre><code class="hljs">[a-z]
</code></pre>
<p>A node:</p>
<pre><code class="hljs css language-js">{
  <span class="hljs-attr">type</span>: <span class="hljs-string">'CharacterClass'</span>,
  <span class="hljs-attr">expressions</span>: [
    {
      <span class="hljs-attr">type</span>: <span class="hljs-string">'ClassRange'</span>,
      <span class="hljs-attr">from</span>: {
        <span class="hljs-attr">type</span>: <span class="hljs-string">'Char'</span>,
        <span class="hljs-attr">value</span>: <span class="hljs-string">'a'</span>,
        <span class="hljs-attr">symbol</span>: <span class="hljs-string">'a'</span>,
        <span class="hljs-attr">kind</span>: <span class="hljs-string">'simple'</span>,
        <span class="hljs-attr">codePoint</span>: <span class="hljs-number">97</span>
      },
      <span class="hljs-attr">to</span>: {
        <span class="hljs-attr">type</span>: <span class="hljs-string">'Char'</span>,
        <span class="hljs-attr">value</span>: <span class="hljs-string">'z'</span>,
        <span class="hljs-attr">symbol</span>: <span class="hljs-string">'z'</span>,
        <span class="hljs-attr">kind</span>: <span class="hljs-string">'simple'</span>,
        <span class="hljs-attr">codePoint</span>: <span class="hljs-number">122</span>
      }
    }
  ]
}
</code></pre>
<blockquote>
<p>NOTE: it is a <em>syntax error</em> if <code>to</code> value is less than <code>from</code> value: <code>/[z-a]/</code>.</p>
</blockquote>
<p>The range value can be the same for <code>from</code> and <code>to</code>, and the special range <code>-</code> character is treated as a simple character when it stands in a char position:</p>
<pre><code class="hljs"><span class="hljs-comment">// from: 'a', to: 'a'</span>
[<span class="hljs-meta">a-a</span>]

<span class="hljs-comment">// from: '-', to: '-'</span>
[<span class="hljs-meta">---</span>]

<span class="hljs-comment">// simple '-' char:</span>
[<span class="hljs-meta">-</span>]

<span class="hljs-comment">// 3 ranges:</span>
[<span class="hljs-meta">a-zA-Z0-9</span>]+
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="unicode-properties"></a><a href="#unicode-properties" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Unicode properties</h4>
<p>Unicode property escapes are a new type of escape sequence available in regular expressions that have the <code>u</code> flag set. With this feature it is possible to write Unicode expressions as:</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">const</span> greekSymbolRe = <span class="hljs-regexp">/\p{Script=Greek}/u</span>;

greekSymbolRe.test(<span class="hljs-string">'π'</span>); <span class="hljs-comment">// true</span>
</code></pre>
<p>The AST node for this expression is:</p>
<pre><code class="hljs css language-js">{
  <span class="hljs-attr">type</span>: <span class="hljs-string">'UnicodeProperty'</span>,
  <span class="hljs-attr">name</span>: <span class="hljs-string">'Script'</span>,
  <span class="hljs-attr">value</span>: <span class="hljs-string">'Greek'</span>,
  <span class="hljs-attr">negative</span>: <span class="hljs-literal">false</span>,
  <span class="hljs-attr">shorthand</span>: <span class="hljs-literal">false</span>,
  <span class="hljs-attr">binary</span>: <span class="hljs-literal">false</span>,
  <span class="hljs-attr">canonicalName</span>: <span class="hljs-string">'Script'</span>,
  <span class="hljs-attr">canonicalValue</span>: <span class="hljs-string">'Greek'</span>
}
</code></pre>
<p>All possible property names, values, and their aliases can be found at the <a href="https://tc39.github.io/ecma262/#sec-runtime-semantics-unicodematchproperty-p">specification</a>.</p>
<p>For <code>General_Category</code> it is possible to use a shorthand:</p>
<pre><code class="hljs css language-js">/\p{Letter}/u;   <span class="hljs-comment">// Shorthand</span>

<span class="hljs-regexp">/\p{General_Category=Letter}/u</span>; <span class="hljs-comment">// Full notation</span>
</code></pre>
<p>Binary names use the single value as well:</p>
<pre><code class="hljs css language-js">/\p{ASCII_Hex_Digit}/u; <span class="hljs-comment">// Same as: /[0-9A-Fa-f]/</span>
</code></pre>
<p>The capitalized <code>P</code> defines the negation of the expression:</p>
<pre><code class="hljs css language-js">/\P{ASCII_Hex_Digit}/u; <span class="hljs-comment">// NOT a ASCII Hex digit</span>
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="alternative"></a><a href="#alternative" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Alternative</h4>
<p>An <em>alternative</em> (or <em>concatenation</em>) defines a chain of patterns followed one after another:</p>
<pre><code class="hljs"><span class="hljs-attribute">abc</span>
</code></pre>
<p>A node:</p>
<pre><code class="hljs css language-js">{
  <span class="hljs-attr">type</span>: <span class="hljs-string">'Alternative'</span>,
  <span class="hljs-attr">expressions</span>: [
    {
      <span class="hljs-attr">type</span>: <span class="hljs-string">'Char'</span>,
      <span class="hljs-attr">value</span>: <span class="hljs-string">'a'</span>,
      <span class="hljs-attr">symbol</span>: <span class="hljs-string">'a'</span>,
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'simple'</span>,
      <span class="hljs-attr">codePoint</span>: <span class="hljs-number">97</span>
    },
    {
      <span class="hljs-attr">type</span>: <span class="hljs-string">'Char'</span>,
      <span class="hljs-attr">value</span>: <span class="hljs-string">'b'</span>,
      <span class="hljs-attr">symbol</span>: <span class="hljs-string">'b'</span>,
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'simple'</span>,
      <span class="hljs-attr">codePoint</span>: <span class="hljs-number">98</span>
    },
    {
      <span class="hljs-attr">type</span>: <span class="hljs-string">'Char'</span>,
      <span class="hljs-attr">value</span>: <span class="hljs-string">'c'</span>,
      <span class="hljs-attr">symbol</span>: <span class="hljs-string">'c'</span>,
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'simple'</span>,
      <span class="hljs-attr">codePoint</span>: <span class="hljs-number">99</span>
    }
  ]
}
</code></pre>
<p>Another examples:</p>
<pre><code class="hljs">// <span class="hljs-string">'a'</span> <span class="hljs-keyword">with</span> <span class="hljs-keyword">a</span> quantifier, followed <span class="hljs-keyword">by</span> <span class="hljs-string">'b'</span>
<span class="hljs-keyword">a</span>?b
<span class="hljs-comment">
// A group followed by a class:</span>
(ab)[<span class="hljs-keyword">a</span>-z]
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="disjunction"></a><a href="#disjunction" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Disjunction</h4>
<p>The <em>disjunction</em> defines &quot;OR&quot; operation for regexp patterns. It's a <em>binary</em> operation, having <code>left</code>, and <code>right</code> nodes.</p>
<p>Matches <code>a</code> or <code>b</code>:</p>
<pre><code class="hljs">a<span class="hljs-string">|b</span>
</code></pre>
<p>A node:</p>
<pre><code class="hljs css language-js">{
  <span class="hljs-attr">type</span>: <span class="hljs-string">'Disjunction'</span>,
  <span class="hljs-attr">left</span>: {
    <span class="hljs-attr">type</span>: <span class="hljs-string">'Char'</span>,
    <span class="hljs-attr">value</span>: <span class="hljs-string">'a'</span>,
    <span class="hljs-attr">symbol</span>: <span class="hljs-string">'a'</span>,
    <span class="hljs-attr">kind</span>: <span class="hljs-string">'simple'</span>,
    <span class="hljs-attr">codePoint</span>: <span class="hljs-number">97</span>
  },
  <span class="hljs-attr">right</span>: {
    <span class="hljs-attr">type</span>: <span class="hljs-string">'Char'</span>,
    <span class="hljs-attr">value</span>: <span class="hljs-string">'b'</span>,
    <span class="hljs-attr">symbol</span>: <span class="hljs-string">'b'</span>,
    <span class="hljs-attr">kind</span>: <span class="hljs-string">'simple'</span>,
    <span class="hljs-attr">codePoint</span>: <span class="hljs-number">98</span>
  }
}
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="groups"></a><a href="#groups" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Groups</h4>
<p>The groups play two roles: they define <em>grouping precedence</em>, and allow to <em>capture</em> needed sub-expressions in case of a capturing group.</p>
<h5><a class="anchor" aria-hidden="true" id="capturing-group"></a><a href="#capturing-group" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Capturing group</h5>
<p><em>&quot;Capturing&quot;</em> means the matched string can be referred later by a user, including in the pattern itself -- by using <a href="#backreferences">backreferences</a>.</p>
<p>Char <code>a</code>, and <code>b</code> are grouped, followed by the <code>c</code> char:</p>
<pre><code class="hljs">(<span class="hljs-name">ab</span>)c
</code></pre>
<p>A node:</p>
<pre><code class="hljs css language-js">{
  <span class="hljs-attr">type</span>: <span class="hljs-string">'Alternative'</span>,
  <span class="hljs-attr">expressions</span>: [
    {
      <span class="hljs-attr">type</span>: <span class="hljs-string">'Group'</span>,
      <span class="hljs-attr">capturing</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">number</span>: <span class="hljs-number">1</span>,
      <span class="hljs-attr">expression</span>: {
        <span class="hljs-attr">type</span>: <span class="hljs-string">'Alternative'</span>,
        <span class="hljs-attr">expressions</span>: [
          {
            <span class="hljs-attr">type</span>: <span class="hljs-string">'Char'</span>,
            <span class="hljs-attr">value</span>: <span class="hljs-string">'a'</span>,
            <span class="hljs-attr">symbol</span>: <span class="hljs-string">'a'</span>,
            <span class="hljs-attr">kind</span>: <span class="hljs-string">'simple'</span>,
            <span class="hljs-attr">codePoint</span>: <span class="hljs-number">97</span>
          },
          {
            <span class="hljs-attr">type</span>: <span class="hljs-string">'Char'</span>,
            <span class="hljs-attr">value</span>: <span class="hljs-string">'b'</span>,
            <span class="hljs-attr">symbol</span>: <span class="hljs-string">'b'</span>,
            <span class="hljs-attr">kind</span>: <span class="hljs-string">'simple'</span>,
            <span class="hljs-attr">codePoint</span>: <span class="hljs-number">98</span>
          }
        ]
      }
    },
    {
      <span class="hljs-attr">type</span>: <span class="hljs-string">'Char'</span>,
      <span class="hljs-attr">value</span>: <span class="hljs-string">'c'</span>,
      <span class="hljs-attr">symbol</span>: <span class="hljs-string">'c'</span>,
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'simple'</span>,
      <span class="hljs-attr">codePoint</span>: <span class="hljs-number">99</span>
    }
  ]
}
</code></pre>
<p>As we can see, it also tracks the number of the group.</p>
<p>Another example:</p>
<pre><code class="hljs">// A grouped disjunction <span class="hljs-keyword">of</span> <span class="hljs-keyword">a</span> symbol, <span class="hljs-keyword">and</span> <span class="hljs-keyword">a</span> <span class="hljs-keyword">character</span> class:
(<span class="hljs-number">5</span>|[<span class="hljs-keyword">a</span>-z])
</code></pre>
<h5><a class="anchor" aria-hidden="true" id="named-capturing-group"></a><a href="#named-capturing-group" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Named capturing group</h5>
<blockquote>
<p>NOTE: <em>Named capturing groups</em> are not yet supported by JavaScript RegExp. It is an ECMAScript <a href="https://tc39.github.io/proposal-regexp-named-groups/">proposal</a> which is at stage 3 at the moment.</p>
</blockquote>
<p>A capturing group can be given a name using the <code>(?&lt;name&gt;...)</code> syntax, for any identifier <code>name</code>.</p>
<p>For example, a regular expressions for a date:</p>
<pre><code class="hljs css language-js">/(?&lt;year&gt;\d{4})-(?&lt;month&gt;\d{2})-(?&lt;day&gt;\d{2})/u
</code></pre>
<p>For the group:</p>
<pre><code class="hljs css language-js">(?<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">foo</span>&gt;</span>x)
</span></code></pre>
<p>We have the following node (the <code>name</code> property with value <code>foo</code> is added):</p>
<pre><code class="hljs css language-js">{
  <span class="hljs-attr">type</span>: <span class="hljs-string">'Group'</span>,
  <span class="hljs-attr">capturing</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">name</span>: <span class="hljs-string">'foo'</span>,
  <span class="hljs-attr">number</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">expression</span>: {
    <span class="hljs-attr">type</span>: <span class="hljs-string">'Char'</span>,
    <span class="hljs-attr">value</span>: <span class="hljs-string">'x'</span>,
    <span class="hljs-attr">symbol</span>: <span class="hljs-string">'x'</span>,
    <span class="hljs-attr">kind</span>: <span class="hljs-string">'simple'</span>,
    <span class="hljs-attr">codePoint</span>: <span class="hljs-number">120</span>
  }
}
</code></pre>
<h5><a class="anchor" aria-hidden="true" id="non-capturing-group"></a><a href="#non-capturing-group" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Non-capturing group</h5>
<p>Sometimes we don't need to actually capture the matched string from a group. In this case we can use a <em>non-capturing</em> group:</p>
<p>Char <code>a</code>, and <code>b</code> are grouped, <em>but not captured</em>, followed by the <code>c</code> char:</p>
<pre><code class="hljs">(?<span class="hljs-symbol">:ab</span>)c
</code></pre>
<p>The same node, the <code>capturing</code> flag is <code>false</code>:</p>
<pre><code class="hljs css language-js">{
  <span class="hljs-attr">type</span>: <span class="hljs-string">'Alternative'</span>,
  <span class="hljs-attr">expressions</span>: [
    {
      <span class="hljs-attr">type</span>: <span class="hljs-string">'Group'</span>,
      <span class="hljs-attr">capturing</span>: <span class="hljs-literal">false</span>,
      <span class="hljs-attr">expression</span>: {
        <span class="hljs-attr">type</span>: <span class="hljs-string">'Alternative'</span>,
        <span class="hljs-attr">expressions</span>: [
          {
            <span class="hljs-attr">type</span>: <span class="hljs-string">'Char'</span>,
            <span class="hljs-attr">value</span>: <span class="hljs-string">'a'</span>,
            <span class="hljs-attr">symbol</span>: <span class="hljs-string">'a'</span>,
            <span class="hljs-attr">kind</span>: <span class="hljs-string">'simple'</span>,
            <span class="hljs-attr">codePoint</span>: <span class="hljs-number">97</span>
          },
          {
            <span class="hljs-attr">type</span>: <span class="hljs-string">'Char'</span>,
            <span class="hljs-attr">value</span>: <span class="hljs-string">'b'</span>,
            <span class="hljs-attr">symbol</span>: <span class="hljs-string">'b'</span>,
            <span class="hljs-attr">kind</span>: <span class="hljs-string">'simple'</span>,
            <span class="hljs-attr">codePoint</span>: <span class="hljs-number">98</span>
          }
        ]
      }
    },
    {
      <span class="hljs-attr">type</span>: <span class="hljs-string">'Char'</span>,
      <span class="hljs-attr">value</span>: <span class="hljs-string">'c'</span>,
      <span class="hljs-attr">symbol</span>: <span class="hljs-string">'c'</span>,
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'simple'</span>,
      <span class="hljs-attr">codePoint</span>: <span class="hljs-number">99</span>
    }
  ]
}
</code></pre>
<h5><a class="anchor" aria-hidden="true" id="backreferences"></a><a href="#backreferences" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Backreferences</h5>
<p>A <a href="#capturing-group">capturing group</a> can be referenced in the pattern using notation of an escaped group number.</p>
<p>Matches <code>abab</code> string:</p>
<pre><code class="hljs">(ab)\<span class="hljs-number">1</span>
</code></pre>
<p>A node:</p>
<pre><code class="hljs css language-js">{
  <span class="hljs-attr">type</span>: <span class="hljs-string">'Alternative'</span>,
  <span class="hljs-attr">expressions</span>: [
    {
      <span class="hljs-attr">type</span>: <span class="hljs-string">'Group'</span>,
      <span class="hljs-attr">capturing</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">number</span>: <span class="hljs-number">1</span>,
      <span class="hljs-attr">expression</span>: {
        <span class="hljs-attr">type</span>: <span class="hljs-string">'Alternative'</span>,
        <span class="hljs-attr">expressions</span>: [
          {
            <span class="hljs-attr">type</span>: <span class="hljs-string">'Char'</span>,
            <span class="hljs-attr">value</span>: <span class="hljs-string">'a'</span>,
            <span class="hljs-attr">symbol</span>: <span class="hljs-string">'a'</span>,
            <span class="hljs-attr">kind</span>: <span class="hljs-string">'simple'</span>,
            <span class="hljs-attr">codePoint</span>: <span class="hljs-number">97</span>
          },
          {
            <span class="hljs-attr">type</span>: <span class="hljs-string">'Char'</span>,
            <span class="hljs-attr">value</span>: <span class="hljs-string">'b'</span>,
            <span class="hljs-attr">symbol</span>: <span class="hljs-string">'b'</span>,
            <span class="hljs-attr">kind</span>: <span class="hljs-string">'simple'</span>,
            <span class="hljs-attr">codePoint</span>: <span class="hljs-number">98</span>
          }
        ]
      }
    },
    {
      <span class="hljs-attr">type</span>: <span class="hljs-string">'Backreference'</span>,
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'number'</span>,
      <span class="hljs-attr">number</span>: <span class="hljs-number">1</span>,
      <span class="hljs-attr">reference</span>: <span class="hljs-number">1</span>,
    }
  ]
}
</code></pre>
<p>A <a href="#named-capturing-group">named capturing group</a> can be accessed using <code>\k&lt;name&gt;</code> pattern, and also using a numbered reference.</p>
<p>Matches <code>www</code>:</p>
<pre><code class="hljs css language-js">(?&lt;foo&gt;w)\k&lt;foo&gt;\1
</code></pre>
<p>A node:</p>
<pre><code class="hljs css language-js">{
  <span class="hljs-attr">type</span>: <span class="hljs-string">'Alternative'</span>,
  <span class="hljs-attr">expressions</span>: [
    {
      <span class="hljs-attr">type</span>: <span class="hljs-string">'Group'</span>,
      <span class="hljs-attr">capturing</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">name</span>: <span class="hljs-string">'foo'</span>,
      <span class="hljs-attr">number</span>: <span class="hljs-number">1</span>,
      <span class="hljs-attr">expression</span>: {
        <span class="hljs-attr">type</span>: <span class="hljs-string">'Char'</span>,
        <span class="hljs-attr">value</span>: <span class="hljs-string">'w'</span>,
        <span class="hljs-attr">symbol</span>: <span class="hljs-string">'w'</span>,
        <span class="hljs-attr">kind</span>: <span class="hljs-string">'simple'</span>,
        <span class="hljs-attr">codePoint</span>: <span class="hljs-number">119</span>
      }
    },
    {
      <span class="hljs-attr">type</span>: <span class="hljs-string">'Backreference'</span>,
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'name'</span>,
      <span class="hljs-attr">number</span>: <span class="hljs-number">1</span>,
      <span class="hljs-attr">reference</span>: <span class="hljs-string">'foo'</span>
    },
    {
      <span class="hljs-attr">type</span>: <span class="hljs-string">'Backreference'</span>,
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'number'</span>,
      <span class="hljs-attr">number</span>: <span class="hljs-number">1</span>,
      <span class="hljs-attr">reference</span>: <span class="hljs-number">1</span>
    }
  ]
}
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="quantifiers"></a><a href="#quantifiers" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Quantifiers</h4>
<p>Quantifiers specify <em>repetition</em> of a regular expression (or of its part). Below are the quantifiers which <em>wrap</em> a parsed expression into a <code>Repetition</code> node. The quantifier itself can be of different <em>kinds</em>, and has <code>Quantifier</code> node type.</p>
<h5><a class="anchor" aria-hidden="true" id="zero-or-one"></a><a href="#zero-or-one" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>? zero-or-one</h5>
<p>The <code>?</code> quantifier is short for <code>{0,1}</code>.</p>
<pre><code class="hljs"><span class="hljs-keyword">a</span>?
</code></pre>
<p>Node:</p>
<pre><code class="hljs css language-js">{
  <span class="hljs-attr">type</span>: <span class="hljs-string">'Repetition'</span>,
  <span class="hljs-attr">expression</span>: {
    <span class="hljs-attr">type</span>: <span class="hljs-string">'Char'</span>,
    <span class="hljs-attr">value</span>: <span class="hljs-string">'a'</span>,
    <span class="hljs-attr">symbol</span>: <span class="hljs-string">'a'</span>,
    <span class="hljs-attr">kind</span>: <span class="hljs-string">'simple'</span>,
    <span class="hljs-attr">codePoint</span>: <span class="hljs-number">97</span>
  },
  <span class="hljs-attr">quantifier</span>: {
    <span class="hljs-attr">type</span>: <span class="hljs-string">'Quantifier'</span>,
    <span class="hljs-attr">kind</span>: <span class="hljs-string">'?'</span>,
    <span class="hljs-attr">greedy</span>: <span class="hljs-literal">true</span>
  }
}
</code></pre>
<h5><a class="anchor" aria-hidden="true" id="zero-or-more"></a><a href="#zero-or-more" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>* zero-or-more</h5>
<p>The <code>*</code> quantifier is short for <code>{0,}</code>.</p>
<pre><code class="hljs"><span class="hljs-keyword">a</span>*
</code></pre>
<p>Node:</p>
<pre><code class="hljs css language-js">{
  <span class="hljs-attr">type</span>: <span class="hljs-string">'Repetition'</span>,
  <span class="hljs-attr">expression</span>: {
    <span class="hljs-attr">type</span>: <span class="hljs-string">'Char'</span>,
    <span class="hljs-attr">value</span>: <span class="hljs-string">'a'</span>,
    <span class="hljs-attr">symbol</span>: <span class="hljs-string">'a'</span>,
    <span class="hljs-attr">kind</span>: <span class="hljs-string">'simple'</span>,
    <span class="hljs-attr">codePoint</span>: <span class="hljs-number">97</span>
  },
  <span class="hljs-attr">quantifier</span>: {
    <span class="hljs-attr">type</span>: <span class="hljs-string">'Quantifier'</span>,
    <span class="hljs-attr">kind</span>: <span class="hljs-string">'*'</span>,
    <span class="hljs-attr">greedy</span>: <span class="hljs-literal">true</span>
  }
}
</code></pre>
<h5><a class="anchor" aria-hidden="true" id="one-or-more"></a><a href="#one-or-more" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>+ one-or-more</h5>
<p>The <code>+</code> quantifier is short for <code>{1,}</code>.</p>
<pre><code class="hljs">// Same as `a<span class="hljs-literal">a</span>*`, <span class="hljs-literal">or</span> `a{<span class="hljs-number">1</span>,}`
<span class="hljs-literal">a</span>+
</code></pre>
<p>Node:</p>
<pre><code class="hljs css language-js">{
  <span class="hljs-attr">type</span>: <span class="hljs-string">'Repetition'</span>,
  <span class="hljs-attr">expression</span>: {
    <span class="hljs-attr">type</span>: <span class="hljs-string">'Char'</span>,
    <span class="hljs-attr">value</span>: <span class="hljs-string">'a'</span>,
    <span class="hljs-attr">symbol</span>: <span class="hljs-string">'a'</span>,
    <span class="hljs-attr">kind</span>: <span class="hljs-string">'simple'</span>,
    <span class="hljs-attr">codePoint</span>: <span class="hljs-number">97</span>
  },
  <span class="hljs-attr">quantifier</span>: {
    <span class="hljs-attr">type</span>: <span class="hljs-string">'Quantifier'</span>,
    <span class="hljs-attr">kind</span>: <span class="hljs-string">'+'</span>,
    <span class="hljs-attr">greedy</span>: <span class="hljs-literal">true</span>
  }
}
</code></pre>
<h5><a class="anchor" aria-hidden="true" id="range-based-quantifiers"></a><a href="#range-based-quantifiers" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Range-based quantifiers</h5>
<p>Explicit <em>range-based</em> quantifiers are parsed as follows:</p>
<h6><a class="anchor" aria-hidden="true" id="exact-number-of-matches"></a><a href="#exact-number-of-matches" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Exact number of matches</h6>
<pre><code class="hljs">a{<span class="hljs-number">3</span>}
</code></pre>
<p>The type of the quantifier is <code>Range</code>, and <code>from</code>, and <code>to</code> properties have the same value:</p>
<pre><code class="hljs css language-js">{
  <span class="hljs-attr">type</span>: <span class="hljs-string">'Repetition'</span>,
  <span class="hljs-attr">expression</span>: {
    <span class="hljs-attr">type</span>: <span class="hljs-string">'Char'</span>,
    <span class="hljs-attr">value</span>: <span class="hljs-string">'a'</span>,
    <span class="hljs-attr">symbol</span>: <span class="hljs-string">'a'</span>,
    <span class="hljs-attr">kind</span>: <span class="hljs-string">'simple'</span>,
    <span class="hljs-attr">codePoint</span>: <span class="hljs-number">97</span>
  },
  <span class="hljs-attr">quantifier</span>: {
    <span class="hljs-attr">type</span>: <span class="hljs-string">'Quantifier'</span>,
    <span class="hljs-attr">kind</span>: <span class="hljs-string">'Range'</span>,
    <span class="hljs-attr">from</span>: <span class="hljs-number">3</span>,
    <span class="hljs-attr">to</span>: <span class="hljs-number">3</span>,
    <span class="hljs-attr">greedy</span>: <span class="hljs-literal">true</span>
  }
}
</code></pre>
<h6><a class="anchor" aria-hidden="true" id="open-range"></a><a href="#open-range" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Open range</h6>
<p>An open range doesn't have max value (assuming semantic &quot;more&quot;, or Infinity value):</p>
<pre><code class="hljs">a{<span class="hljs-number">3</span>,}
</code></pre>
<p>An AST node for such range doesn't contain <code>to</code> property:</p>
<pre><code class="hljs css language-js">{
  <span class="hljs-attr">type</span>: <span class="hljs-string">'Repetition'</span>,
  <span class="hljs-attr">expression</span>: {
    <span class="hljs-attr">type</span>: <span class="hljs-string">'Char'</span>,
    <span class="hljs-attr">value</span>: <span class="hljs-string">'a'</span>,
    <span class="hljs-attr">symbol</span>: <span class="hljs-string">'a'</span>,
    <span class="hljs-attr">kind</span>: <span class="hljs-string">'simple'</span>,
    <span class="hljs-attr">codePoint</span>: <span class="hljs-number">97</span>
  },
  <span class="hljs-attr">quantifier</span>: {
    <span class="hljs-attr">type</span>: <span class="hljs-string">'Quantifier'</span>,
    <span class="hljs-attr">kind</span>: <span class="hljs-string">'Range'</span>,
    <span class="hljs-attr">from</span>: <span class="hljs-number">3</span>,
    <span class="hljs-attr">greedy</span>: <span class="hljs-literal">true</span>
  }
}
</code></pre>
<h6><a class="anchor" aria-hidden="true" id="closed-range"></a><a href="#closed-range" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Closed range</h6>
<p>A closed range has explicit max value: (which syntactically can be the same as min value):</p>
<pre><code class="hljs">a{<span class="hljs-number">3</span>,<span class="hljs-number">5</span>}

<span class="hljs-comment">// Same as a{3}</span>
a{<span class="hljs-number">3</span>,<span class="hljs-number">3</span>}
</code></pre>
<p>An AST node for a closed range:</p>
<pre><code class="hljs css language-js">{
  <span class="hljs-attr">type</span>: <span class="hljs-string">'Repetition'</span>,
  <span class="hljs-attr">expression</span>: {
    <span class="hljs-attr">type</span>: <span class="hljs-string">'Char'</span>,
    <span class="hljs-attr">value</span>: <span class="hljs-string">'a'</span>,
    <span class="hljs-attr">symbol</span>: <span class="hljs-string">'a'</span>,
    <span class="hljs-attr">kind</span>: <span class="hljs-string">'simple'</span>,
    <span class="hljs-attr">codePoint</span>: <span class="hljs-number">97</span>
  },
  <span class="hljs-attr">quantifier</span>: {
    <span class="hljs-attr">type</span>: <span class="hljs-string">'Quantifier'</span>,
    <span class="hljs-attr">kind</span>: <span class="hljs-string">'Range'</span>,
    <span class="hljs-attr">from</span>: <span class="hljs-number">3</span>,
    <span class="hljs-attr">to</span>: <span class="hljs-number">5</span>,
    <span class="hljs-attr">greedy</span>: <span class="hljs-literal">true</span>
  }
}
</code></pre>
<blockquote>
<p>NOTE: it is a <em>syntax error</em> if the max value is less than min value: <code>/a{3,2}/</code></p>
</blockquote>
<h5><a class="anchor" aria-hidden="true" id="non-greedy"></a><a href="#non-greedy" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Non-greedy</h5>
<p>If any quantifier is followed by the <code>?</code>, the quantifier becomes <em>non-greedy</em>.</p>
<p>Example:</p>
<pre><code class="hljs"><span class="hljs-keyword">a</span>+?
</code></pre>
<p>Node:</p>
<pre><code class="hljs css language-js">{
  <span class="hljs-attr">type</span>: <span class="hljs-string">'Repetition'</span>,
  <span class="hljs-attr">expression</span>: {
    <span class="hljs-attr">type</span>: <span class="hljs-string">'Char'</span>,
    <span class="hljs-attr">value</span>: <span class="hljs-string">'a'</span>,
    <span class="hljs-attr">symbol</span>: <span class="hljs-string">'a'</span>,
    <span class="hljs-attr">kind</span>: <span class="hljs-string">'simple'</span>,
    <span class="hljs-attr">codePoint</span>: <span class="hljs-number">97</span>
  },
  <span class="hljs-attr">quantifier</span>: {
    <span class="hljs-attr">type</span>: <span class="hljs-string">'Quantifier'</span>,
    <span class="hljs-attr">kind</span>: <span class="hljs-string">'+'</span>,
    <span class="hljs-attr">greedy</span>: <span class="hljs-literal">false</span>
  }
}
</code></pre>
<p>Other examples:</p>
<pre><code class="hljs">a??
a*?
a{<span class="hljs-number">1</span>}?
a{<span class="hljs-number">1</span>,}?
a{<span class="hljs-number">1</span>,<span class="hljs-number">3</span>}?
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="assertions"></a><a href="#assertions" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Assertions</h4>
<p>Assertions appear as separate AST nodes, however instread of manipulating on the characters themselves, they <em>assert</em> certain conditions of a matching string. Examples: <code>^</code> -- beginning of a string (or a line in multiline mode), <code>$</code> -- end of a string, etc.</p>
<h5><a class="anchor" aria-hidden="true" id="begin-marker"></a><a href="#begin-marker" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>^ begin marker</h5>
<p>The <code>^</code> assertion checks whether a scanner is at the beginning of a string (or a line in multiline mode).</p>
<p>In the example below <code>^</code> is not a property of the <code>a</code> symbol, but a separate AST node for the assertion. The parsed node is actually an <code>Alternative</code> with two nodes:</p>
<pre><code class="hljs">^<span class="hljs-selector-tag">a</span>
</code></pre>
<p>The node:</p>
<pre><code class="hljs css language-js">{
  <span class="hljs-attr">type</span>: <span class="hljs-string">'Alternative'</span>,
  <span class="hljs-attr">expressions</span>: [
    {
      <span class="hljs-attr">type</span>: <span class="hljs-string">'Assertion'</span>,
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'^'</span>
    },
    {
      <span class="hljs-attr">type</span>: <span class="hljs-string">'Char'</span>,
      <span class="hljs-attr">value</span>: <span class="hljs-string">'a'</span>,
      <span class="hljs-attr">symbol</span>: <span class="hljs-string">'a'</span>,
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'simple'</span>,
      <span class="hljs-attr">codePoint</span>: <span class="hljs-number">97</span>
    }
  ]
}
</code></pre>
<p>Since assertion is a separate node, it may appear anywhere in the matching string. The following regexp is completely valid, and asserts beginning of the string; it'll match an empty string:</p>
<pre><code class="hljs">^^^^^
</code></pre>
<h5><a class="anchor" aria-hidden="true" id="end-marker"></a><a href="#end-marker" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>$ end marker</h5>
<p>The <code>$</code> assertion is similar to <code>^</code>, but asserts the end of a string (or a line in a multiline mode):</p>
<pre><code class="hljs">a<span class="hljs-variable">$
</span></code></pre>
<p>A node:</p>
<pre><code class="hljs css language-js">{
  <span class="hljs-attr">type</span>: <span class="hljs-string">'Alternative'</span>,
  <span class="hljs-attr">expressions</span>: [
    {
      <span class="hljs-attr">type</span>: <span class="hljs-string">'Char'</span>,
      <span class="hljs-attr">value</span>: <span class="hljs-string">'a'</span>,
      <span class="hljs-attr">symbol</span>: <span class="hljs-string">'a'</span>,
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'simple'</span>,
      <span class="hljs-attr">codePoint</span>: <span class="hljs-number">97</span>
    },
    {
      <span class="hljs-attr">type</span>: <span class="hljs-string">'Assertion'</span>,
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'$'</span>
    }
  ]
}
</code></pre>
<p>And again, this is a completely valid regexp, and matches an empty string:</p>
<pre><code class="hljs">^^^^<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>

<span class="hljs-comment">// valid too:</span>
<span class="hljs-symbol">$</span>^
</code></pre>
<h5><a class="anchor" aria-hidden="true" id="boundary-assertions"></a><a href="#boundary-assertions" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Boundary assertions</h5>
<p>The <code>\b</code> assertion check for <em>word boundary</em>, i.e. the position between a word and a space.</p>
<p>Matches <code>x</code> in <code>x y</code>, but not in <code>xy</code>:</p>
<pre><code class="hljs">x\<span class="hljs-selector-tag">b</span>
</code></pre>
<p>A node:</p>
<pre><code class="hljs css language-js">{
  <span class="hljs-attr">type</span>: <span class="hljs-string">'Alternative'</span>,
  <span class="hljs-attr">expressions</span>: [
    {
      <span class="hljs-attr">type</span>: <span class="hljs-string">'Char'</span>,
      <span class="hljs-attr">value</span>: <span class="hljs-string">'x'</span>,
      <span class="hljs-attr">symbol</span>: <span class="hljs-string">'x'</span>,
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'simple'</span>,
      <span class="hljs-attr">codePoint</span>: <span class="hljs-number">120</span>
    },
    {
      <span class="hljs-attr">type</span>: <span class="hljs-string">'Assertion'</span>,
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'\\b'</span>
    }
  ]
}
</code></pre>
<p>The <code>\B</code> is vice-versa checks for <em>non-word</em> boundary. The following example matches <code>x</code> in <code>xy</code>, but not in <code>x y</code>:</p>
<pre><code class="hljs">x\<span class="hljs-keyword">B
</span></code></pre>
<p>A node is the same:</p>
<pre><code class="hljs css language-js">{
  <span class="hljs-attr">type</span>: <span class="hljs-string">'Alternative'</span>,
  <span class="hljs-attr">expressions</span>: [
    {
      <span class="hljs-attr">type</span>: <span class="hljs-string">'Char'</span>,
      <span class="hljs-attr">value</span>: <span class="hljs-string">'x'</span>,
      <span class="hljs-attr">symbol</span>: <span class="hljs-string">'x'</span>,
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'simple'</span>,
      <span class="hljs-attr">codePoint</span>: <span class="hljs-number">120</span>
    },
    {
      <span class="hljs-attr">type</span>: <span class="hljs-string">'Assertion'</span>,
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'\\B'</span>
    }
  ]
}
</code></pre>
<h5><a class="anchor" aria-hidden="true" id="lookahead-assertions"></a><a href="#lookahead-assertions" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Lookahead assertions</h5>
<p>These assertions check whether a pattern is <em>followed</em> (or not followed for the negative assertion) by another pattern.</p>
<h6><a class="anchor" aria-hidden="true" id="positive-lookahead-assertion"></a><a href="#positive-lookahead-assertion" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Positive lookahead assertion</h6>
<p>Matches <code>a</code> only if it's followed by <code>b</code>:</p>
<pre><code class="hljs"><span class="hljs-function"><span class="hljs-title">a</span><span class="hljs-params">(?=b)</span></span>
</code></pre>
<p>A node:</p>
<pre><code class="hljs css language-js">{
  <span class="hljs-attr">type</span>: <span class="hljs-string">'Alternative'</span>,
  <span class="hljs-attr">expressions</span>: [
    {
      <span class="hljs-attr">type</span>: <span class="hljs-string">'Char'</span>,
      <span class="hljs-attr">value</span>: <span class="hljs-string">'a'</span>,
      <span class="hljs-attr">symbol</span>: <span class="hljs-string">'a'</span>,
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'simple'</span>,
      <span class="hljs-attr">codePoint</span>: <span class="hljs-number">97</span>
    },
    {
      <span class="hljs-attr">type</span>: <span class="hljs-string">'Assertion'</span>,
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'Lookahead'</span>,
      <span class="hljs-attr">assertion</span>: {
        <span class="hljs-attr">type</span>: <span class="hljs-string">'Char'</span>,
        <span class="hljs-attr">value</span>: <span class="hljs-string">'b'</span>,
        <span class="hljs-attr">symbol</span>: <span class="hljs-string">'b'</span>,
        <span class="hljs-attr">kind</span>: <span class="hljs-string">'simple'</span>,
        <span class="hljs-attr">codePoint</span>: <span class="hljs-number">98</span>
      }
    }
  ]
}
</code></pre>
<h6><a class="anchor" aria-hidden="true" id="negative-lookahead-assertion"></a><a href="#negative-lookahead-assertion" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Negative lookahead assertion</h6>
<p>Matches <code>a</code> only if it's <em>not</em> followed by <code>b</code>:</p>
<pre><code class="hljs"><span class="hljs-function"><span class="hljs-title">a</span><span class="hljs-params">(?!b)</span></span>
</code></pre>
<p>A node is similar, just <code>negative</code> flag is added:</p>
<pre><code class="hljs css language-js">{
  <span class="hljs-attr">type</span>: <span class="hljs-string">'Alternative'</span>,
  <span class="hljs-attr">expressions</span>: [
    {
      <span class="hljs-attr">type</span>: <span class="hljs-string">'Char'</span>,
      <span class="hljs-attr">value</span>: <span class="hljs-string">'a'</span>,
      <span class="hljs-attr">symbol</span>: <span class="hljs-string">'a'</span>,
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'simple'</span>,
      <span class="hljs-attr">codePoint</span>: <span class="hljs-number">97</span>
    },
    {
      <span class="hljs-attr">type</span>: <span class="hljs-string">'Assertion'</span>,
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'Lookahead'</span>,
      <span class="hljs-attr">negative</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">assertion</span>: {
        <span class="hljs-attr">type</span>: <span class="hljs-string">'Char'</span>,
        <span class="hljs-attr">value</span>: <span class="hljs-string">'b'</span>,
        <span class="hljs-attr">symbol</span>: <span class="hljs-string">'b'</span>,
        <span class="hljs-attr">kind</span>: <span class="hljs-string">'simple'</span>,
        <span class="hljs-attr">codePoint</span>: <span class="hljs-number">98</span>
      }
    }
  ]
}
</code></pre>
<h5><a class="anchor" aria-hidden="true" id="lookbehind-assertions"></a><a href="#lookbehind-assertions" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Lookbehind assertions</h5>
<blockquote>
<p>NOTE: <em>Lookbehind assertions</em> are not yet supported by JavaScript RegExp. It is an ECMAScript <a href="https://tc39.github.io/proposal-regexp-lookbehind/">proposal</a> which is at stage 3 at the moment.</p>
</blockquote>
<p>These assertions check whether a pattern is <em>preceded</em> (or not preceded for the negative assertion) by another pattern.</p>
<h6><a class="anchor" aria-hidden="true" id="positive-lookbehind-assertion"></a><a href="#positive-lookbehind-assertion" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Positive lookbehind assertion</h6>
<p>Matches <code>b</code> only if it's preceded by <code>a</code>:</p>
<pre><code class="hljs"><span class="hljs-comment">(?&lt;=a)</span>b
</code></pre>
<p>A node:</p>
<pre><code class="hljs css language-js">{
  <span class="hljs-attr">type</span>: <span class="hljs-string">'Alternative'</span>,
  <span class="hljs-attr">expressions</span>: [
    {
      <span class="hljs-attr">type</span>: <span class="hljs-string">'Assertion'</span>,
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'Lookbehind'</span>,
      <span class="hljs-attr">assertion</span>: {
        <span class="hljs-attr">type</span>: <span class="hljs-string">'Char'</span>,
        <span class="hljs-attr">value</span>: <span class="hljs-string">'a'</span>,
        <span class="hljs-attr">symbol</span>: <span class="hljs-string">'a'</span>,
        <span class="hljs-attr">kind</span>: <span class="hljs-string">'simple'</span>,
        <span class="hljs-attr">codePoint</span>: <span class="hljs-number">97</span>
      }
    },
    {
      <span class="hljs-attr">type</span>: <span class="hljs-string">'Char'</span>,
      <span class="hljs-attr">value</span>: <span class="hljs-string">'b'</span>,
      <span class="hljs-attr">symbol</span>: <span class="hljs-string">'b'</span>,
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'simple'</span>,
      <span class="hljs-attr">codePoint</span>: <span class="hljs-number">98</span>
    },
  ]
}
</code></pre>
<h6><a class="anchor" aria-hidden="true" id="negative-lookbehind-assertion"></a><a href="#negative-lookbehind-assertion" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Negative lookbehind assertion</h6>
<p>Matches <code>b</code> only if it's <em>not</em> preceded by <code>a</code>:</p>
<pre><code class="hljs"><span class="hljs-comment">(?&lt;!a)</span>b
</code></pre>
<p>A node:</p>
<pre><code class="hljs css language-js">{
  <span class="hljs-attr">type</span>: <span class="hljs-string">'Alternative'</span>,
  <span class="hljs-attr">expressions</span>: [
    {
      <span class="hljs-attr">type</span>: <span class="hljs-string">'Assertion'</span>,
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'Lookbehind'</span>,
      <span class="hljs-attr">negative</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">assertion</span>: {
        <span class="hljs-attr">type</span>: <span class="hljs-string">'Char'</span>,
        <span class="hljs-attr">value</span>: <span class="hljs-string">'a'</span>,
        <span class="hljs-attr">symbol</span>: <span class="hljs-string">'a'</span>,
        <span class="hljs-attr">kind</span>: <span class="hljs-string">'simple'</span>,
        <span class="hljs-attr">codePoint</span>: <span class="hljs-number">97</span>
      }
    },
    {
      <span class="hljs-attr">type</span>: <span class="hljs-string">'Char'</span>,
      <span class="hljs-attr">value</span>: <span class="hljs-string">'b'</span>,
      <span class="hljs-attr">symbol</span>: <span class="hljs-string">'b'</span>,
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'simple'</span>,
      <span class="hljs-attr">codePoint</span>: <span class="hljs-number">98</span>
    },
  ]
}
</code></pre>
</span></div></article></div><div class="docs-prevnext"></div></div></div><nav class="onPageNav"></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/underbase/" class="nav-home"><img src="/underbase/img/logo.svg" alt="Underbase" width="66" height="58"/></a><div><h5>Docs</h5><a href="/underbase/docs/en/doc1.html">Getting Started (or other categories)</a><a href="/underbase/docs/en/doc2.html">Guides (or other categories)</a><a href="/underbase/docs/en/doc3.html">API Reference (or other categories)</a></div><div><h5>Community</h5><a href="https://stackoverflow.com/questions/tagged/" target="_blank" rel="noreferrer noopener">Stack Overflow</a><a href="https://discordapp.com/">Project Chat</a><a href="https://twitter.com/" target="_blank" rel="noreferrer noopener">Twitter</a></div><div><h5>More</h5><a href="/underbase/blog">Blog</a><a href="https://github.com/">GitHub</a><a class="github-button" data-icon="octicon-star" data-count-href="/facebook/docusaurus/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div></section></footer></div></body></html>